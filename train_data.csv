function_code,test_code
"func (m MockJiraSvc) ValidEpicKey(requestType ombentities.TaskClass, source string, key string) bool {
	if m.ValidEpicKeyFn != nil {
		return m.ValidEpicKeyFn(requestType, source, key)
	}
	return false
}","func TestValidEpicKey(t *testing.T) {
	t.Run(""key is missing"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		result := jiraSvc.ValidEpicKey("""", """", """")
		assert.Equal(t, false, result)
	})
	t.Run(""RequestType: Provisioning, Source:MDP and correct EPIC key"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		jiraSvc.mdpProvEpicKey = issueID121
		result := jiraSvc.ValidEpicKey(ombentities.TaskClassProvisioning, ""MDP"", issueID121)
		assert.Equal(t, true, result)
	})
	t.Run(""RequestType: Provisioning, Source:MDP and incorrect EPIC key"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		jiraSvc.mdpProvEpicKey = issueID124
		result := jiraSvc.ValidEpicKey(ombentities.TaskClassProvisioning, ""MDP"", issueID121)
		assert.Equal(t, false, result)
	})
	t.Run(""RequestType: Decommissioning, Source:MDP and correct EPIC key"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		jiraSvc.mdpDecomEpicKey = issueID124
		result := jiraSvc.ValidEpicKey(ombentities.TaskClassDecommissioning, ""MDP"", issueID124)
		assert.Equal(t, true, result)
	})
	t.Run(""RequestType: Decommissioning, Source:MDP and incorrect EPIC key"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		jiraSvc.mdpDecomEpicKey = ""MNBS-244""
		result := jiraSvc.ValidEpicKey(ombentities.TaskClassDecommissioning, ""MDP"", issueID124)
		assert.Equal(t, false, result)
	})
	t.Run(""RequestType: Provisioning, Source:Perptual_NonMDP and correct EPIC key"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		jiraSvc.nonMdpProvEpicKey = issueID999
		result := jiraSvc.ValidEpicKey(ombentities.TaskClassProvisioning, ""Perpetual_NonMDP"", issueID999)
		assert.Equal(t, true, result)
	})
	t.Run(""RequestType: Provisioning, Source:Perptual_NonMDP and incorrect EPIC key"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		jiraSvc.nonMdpProvEpicKey = issueID999
		result := jiraSvc.ValidEpicKey(ombentities.TaskClassProvisioning, ""Perpetual_NonMDP"", ""MNBS-1000"")
		assert.Equal(t, false, result)
	})
	t.Run(""RequestType: Decommissioning, Source:Perptual_NonMDP and correct EPIC key"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		jiraSvc.nonMdpDecomEpicKey = issueID1111
		result := jiraSvc.ValidEpicKey(ombentities.TaskClassDecommissioning, ""Perpetual_NonMDP"", issueID1111)
		assert.Equal(t, true, result)
	})
	t.Run(""RequestType: Decommissioning, Source:Perptual_NonMDP and incorrect EPIC key"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		jiraSvc.nonMdpDecomEpicKey = issueID1111
		result := jiraSvc.ValidEpicKey(ombentities.TaskClassDecommissioning, ""Perpetual_NonMDP"", ""MNBS-1110"")
		assert.Equal(t, false, result)
	})
	t.Run(""Default case"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		jiraSvc.nonMdpDecomEpicKey = issueID1111
		result := jiraSvc.ValidEpicKey(ombentities.TaskClassDecommissioning, ""Perpetual"", ""MNBS-1110"")
		assert.Equal(t, false, result)
	})

}"
"func (r *MockReaderWithError) Close() error {
	r.closed = true
	return nil // Or return a specific error if needed
}","func TestClose(t *testing.T) {
	t.Run(testMessage, func(t *testing.T) {
		mockReader := MockReaderWithError{err: errors.New(errMessage), closed: false}
		err := mockReader.Close()
		assert.Nil(t, err)
		if !mockReader.closed {
			t.Errorf(""failed to set mockereader.closed as true"")
		}
	})

}"
"func (svc approvalSvc) GetApproval(params map[string]string) (interface{}, error) {
	if svc.authToken == nil || svc.client == nil {
		return nil, errors.New(""Approval service is not initialized"")
	}
	req, err := http.NewRequest(http.MethodGet, svc.approvalURL, nil)
	if err != nil {
		logger.L.Error(""Error while forming the Request object"", zap.Error(err))
		return nil, err
	}
	//Build Get URL Query
	query := helper.BuildURLQuery(req, params)
	req.URL.RawQuery = query.Encode()
	logger.L.Info(""Approval URL formed "", zap.Any(""URL"", req.URL.String()))
	req = helper.JSONHeadersMiddleware(req, svc.authToken.AccessToken)

	return helper.HTTPClient(req, svc.client)
}","func TestGetApproval(t *testing.T) {
	mockAuthToken := &entities.AuthToken{AccessToken: ""testAccessToken""}
	approvalURL := ""http://test.com/approval""

	t.Run(""Successfully gets approval"", func(t *testing.T) {
		mockTransport := &mocks.MockRoundTripper{
			RoundTripFn: func(req *http.Request) *http.Response {
				assert.Equal(t, req.URL.RawQuery, ""key=value"", ""Expected query parameters to match"")
				return &http.Response{
					StatusCode: http.StatusOK,
					Body:       ioutil.NopCloser(strings.NewReader(`{""status"": ""success""}`)),
					Header:     make(http.Header),
				}
			},
		}
		mockClient := &http.Client{Transport: mockTransport}

		mockSvc := approvalSvc{
			authToken:   mockAuthToken,
			approvalURL: approvalURL,
			client:      mockClient,
		}

		params := map[string]string{""key"": ""value""}
		result, err := mockSvc.GetApproval(params)
		assert.NoError(t, err, ""Expected no error"")
		assert.NotNil(t, result, ""Expected a valid response"")
		assert.Equal(t, ""success"", result.(map[string]interface{})[""status""], ""Expected status to be 'success'"")
	})

	t.Run(""Fails due to uninitialized service"", func(t *testing.T) {
		mockSvc := approvalSvc{}
		params := map[string]string{""key"": ""value""}

		result, err := mockSvc.GetApproval(params)
		assert.Error(t, err, ""Expected an error"")
		assert.Nil(t, result, ""Expected result to be nil"")
	})

	t.Run(""Fails to create HTTP request"", func(t *testing.T) {
		client := &http.Client{}
		mockSvc := approvalSvc{
			authToken:   mockAuthToken,
			approvalURL: ""http://invalid-url%"",
			client: client,
		}
		params := map[string]string{""key"": ""value""}

		result, err := mockSvc.GetApproval(params)
		assert.Error(t, err, ""Expected an error due to invalid URL"")
		assert.Nil(t, result, ""Expected result to be nil"")
	})
}"
"func NewPrometheusMeter(name string) (api.Meter, error) {
	// The exporter embeds a default OpenTelemetry Reader and
	// implements prometheus.Collector, allowing it to be used as
	// both a Reader and Collector.
	exporter, err := prometheusNewfn()
	if err != nil {
		return nil, err
	}
	provider := metric.NewMeterProvider(metric.WithReader(exporter))
	return provider.Meter(name), nil
}","func TestNewPrometheusMeter(t *testing.T) {
	originalPrometheusNew := prometheusNewfn
	defer func() {
		prometheusNewfn = originalPrometheusNew
	}()

	t.Run(""Success"", func(t *testing.T) {
		prometheusNewfn = func(opts ...prometheus.Option) (*prometheus.Exporter, error) {
			exporter, err := prometheus.New(opts...)
			assert.NoError(t, err)	
			return exporter, nil
		}

		meter, err := NewPrometheusMeter(""test-meter"")
		assert.NoError(t, err, ""Expected no error but got one"")
		assert.NotNil(t, meter, ""Expected a valid meter but got nil"")
	})

	t.Run(""Failure"", func(t *testing.T) {
		prometheusNewfn = func(opts ...prometheus.Option) (*prometheus.Exporter, error) {
			return nil, errors.New(""error"")
		}

		meter, err := NewPrometheusMeter(""test-meter"")
		assert.Error(t, err, ""Expected an error but got none"")
		assert.Nil(t, meter, ""Expected nil meter on error"")
	})
}"
"func Ready() bool {
	t1, t2 := FetchCurrentToken()
	return len(t1) != 0 && len(t2) != 0
}","func TestReady(t *testing.T) {
	val := Ready()
	assert.NotNil(t, val)
}"
"func NewMockSecretStore(opts ...MockOptions) interfaces.SecretStore {
	m := mockSecretStore{}
	for _, opt := range opts {
		if opt == nil {
			continue
		}
		opt(&m)
	}
	return m
}","func TestNewMockSecretStore(t *testing.T) {
	// default behaviour
	m := NewMockSecretStore(nil)
	assert.NotNil(t, m)
	ctx := context.Background()
	sampleKey := ""sample""
	sampleValue := ""simple""
	val, err := m.GetSecret(ctx, sampleKey)
	assert.Empty(t, val)
	assert.Nil(t, err)
	err = m.SetSecret(ctx, sampleKey, sampleValue)
	assert.Nil(t, err)
	err = m.DeleteSecret(ctx, sampleKey)
	assert.Nil(t, err)

	// with get secret, set and delete should exhibit default behaviour
	m = NewMockSecretStore(WithGetSecret(func(ctx context.Context, s string) (string, error) {
		return sampleValue, nil
	}))
	val, err = m.GetSecret(ctx, sampleKey)
	assert.NotEmpty(t, val)
	assert.Equal(t, val, sampleValue)
	assert.Nil(t, err)
	err = m.SetSecret(ctx, sampleKey, sampleValue)
	assert.Nil(t, err)
	err = m.DeleteSecret(ctx, sampleKey)
	assert.Nil(t, err)
	m = NewMockSecretStore(WithGetSecret(func(ctx context.Context, s string) (string, error) {
		return """", errors.New(""secret fetch error"")
	}))
	val, err = m.GetSecret(ctx, sampleKey)
	assert.Empty(t, val)
	assert.NotNil(t, err)
	err = m.SetSecret(ctx, sampleKey, sampleValue)
	assert.Nil(t, err)
	err = m.DeleteSecret(ctx, sampleKey)
	assert.Nil(t, err)

	// with set secret, get and delete should exhibit default behaviour
	m = NewMockSecretStore(WithSetSecret(func(ctx context.Context, k, v string) error {
		return nil
	}))
	err = m.SetSecret(ctx, sampleKey, sampleValue)
	assert.Nil(t, err)
	val, err = m.GetSecret(ctx, sampleKey)
	assert.Empty(t, val)
	assert.Nil(t, err)
	err = m.DeleteSecret(ctx, sampleKey)
	assert.Nil(t, err)
	m = NewMockSecretStore(WithSetSecret(func(ctx context.Context, k, v string) error {
		return errors.New(""secret set error"")
	}))
	err = m.SetSecret(ctx, sampleKey, sampleValue)
	assert.NotNil(t, err)
	val, err = m.GetSecret(ctx, sampleKey)
	assert.Empty(t, val)
	assert.Nil(t, err)
	err = m.DeleteSecret(ctx, sampleKey)
	assert.Nil(t, err)

	// with delete secret, get and set should exhibit default behaviour
	m = NewMockSecretStore(WithDeleteSecret(func(ctx context.Context, k string) error {
		return nil
	}))
	err = m.DeleteSecret(ctx, sampleKey)
	assert.Nil(t, err)
	val, err = m.GetSecret(ctx, sampleKey)
	assert.Empty(t, val)
	assert.Nil(t, err)
	err = m.SetSecret(ctx, sampleKey, sampleValue)
	assert.Nil(t, err)
	m = NewMockSecretStore(WithDeleteSecret(func(ctx context.Context, k string) error {
		return errors.New(""secret delete error"")
	}))
	err = m.DeleteSecret(ctx, sampleKey)
	assert.NotNil(t, err)
	val, err = m.GetSecret(ctx, sampleKey)
	assert.Empty(t, val)
	assert.Nil(t, err)
	err = m.SetSecret(ctx, sampleKey, sampleValue)
	assert.Nil(t, err)
}"
"func WithIsReady(fn func(context.Context) error) MockOptions{
	return func(mss *mockSecretStore) {
		mss.IsReadyFn = fn
	}
}","func TestWithIsReady(t *testing.T) {
	m := NewMockSecretStore(WithIsReady(func(ctx context.Context) error {
		return nil
	}))
	err := m.IsReady(context.Background())
	assert.Nil(t, err)
	m = NewMockSecretStore(WithIsReady(func(ctx context.Context) error {
		return errors.New(""is ready error"")
	}))
	err = m.IsReady(context.Background())
	assert.NotNil(t, err)
}"
"func (db unitRepository) Health(ctx context.Context) error {
	_, span := dbTracer.Start(ctx, ""Health"")
	defer span.End()
	if db.conn == nil {
		return errors.New(""unit repository not initialized: missing db connection"")
	}
	return db.conn.Ping(ctx)
}","func TestHealth(t *testing.T) {
	svc := NewServiceFactory().WithTracer(testTracer).Finalize()
	assert.NotNil(t, svc)
	err := svc.Health(context.TODO())
	assert.Nil(t, err)
	svc = NewServiceFactory().WithTracer(testTracer).WithRepository(mocks.NewRepository()).Finalize()
	assert.NotNil(t, svc)
	err = svc.Health(context.TODO())
	assert.Nil(t, err)
}"
"func NewResource(ctx context.Context, serviceName string, attributes map[string]string) (*resource.Resource, error) {
	if serviceName == """" {
	return nil, fmt.Errorf(""service name cannot be empty"")
	}
	attrs := []attribute.KeyValue{
		// the service name used to display traces in backends
		semconv.ServiceNameKey.String(serviceName),
	}
	for k, v := range attributes {
		attrs = append(attrs, attribute.String(k, v))
	}
	return resource.New(ctx,
		resource.WithAttributes(attrs...),
	)
}","func TestNewResource(t *testing.T) {
	tests := []struct {
		name          string
		serviceName   string
		attributes    map[string]string
		expectedError bool
		expectedAttrs []attribute.KeyValue
	}{
		{
			name:        ""Success - Valid Inputs"",
			serviceName: ""test-service"",
			attributes: map[string]string{
				""env"":  ""test"",
				""tier"": ""backend"",
			},
			expectedError: false,
			expectedAttrs: []attribute.KeyValue{
				semconv.ServiceNameKey.String(""test-service""),
				attribute.String(""env"", ""test""),
				attribute.String(""tier"", ""backend""),
			},
		},
		{
			name:          ""Failure - Empty Service Name"",
			serviceName:   """",
			attributes:    map[string]string{},
			expectedError: true,
			expectedAttrs: nil,
		},
		{
			name:          ""Success - Empty Attributes"",
			serviceName:   ""test-service"",
			attributes:    map[string]string{},
			expectedError: false,
			expectedAttrs: []attribute.KeyValue{
				semconv.ServiceNameKey.String(""test-service""),
			},
		},
	}
	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			ctx := context.Background()
			res, err := NewResource(ctx, tc.serviceName, tc.attributes)

			if tc.expectedError {
				assert.Error(t, err, ""expected an error"")
				assert.Nil(t, res, ""expected resource to be nil"")
				return
			}

			assert.NoError(t, err, ""did not expect an error"")
			assert.NotNil(t, res, ""expected resource to be non-nil"")

			for _, expectedAttr := range tc.expectedAttrs {
				assert.Contains(t, res.Attributes(), expectedAttr, ""expected attribute not found"")
			}
		})
	}
}"
"func (db unitRepository) GetTemplate(ctx context.Context, resourceID string) (ombentities.Template, error) {
	_, span := dbTracer.Start(ctx, ""DBFetchLatestState"")
	defer span.End()
	if db.conn == nil {
		return ombentities.Template{}, errors.New(""repository not initialized: missing db connection"")
	}
	res := db.conn.QueryRow(ctx, `
	SELECT 
		job_id
		, resource_group_name
		, tdata
		, created_at
	FROM 
		templates
	WHERE 
		resource_id = $1
	`, resourceID)

	var (
		jobID, rgName, tdata string
		createdAt            time.Time
	)

	if err := res.Scan(
		&jobID, &rgName, &tdata,
		&createdAt); err != nil {
		return ombentities.Template{}, fmt.Errorf(""couldnt read template: %v"", err)
	}
	var t ombentities.Template
	if err := json.Unmarshal([]byte(tdata), &t); err != nil {
		return ombentities.Template{}, fmt.Errorf(""couldnt parse template: %v"", err)
	}
	return t, nil
}","func TestGetTemplate(t *testing.T) {
	mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case ""/testTemplate"":
			template := ombentities.Template{}
			json.NewEncoder(w).Encode(template)
		default:
			http.Error(w, ""not found"", http.StatusNotFound)
		}
	}))
	defer mockServer.Close()

	cfg := config.ExternalService{
		URL:              mockServer.URL,
		TimeoutInSeconds: 2,
	}
	err := templatorservice.Initialize(cfg)
	assert.Nil(t, err, ""template service initialization should not return an error"")

	req := provent.Resource{}
	plan := ombentities.Plan{Name: ""TestPlan""}

	t.Run(""GetTemplate returns error"", func(t *testing.T) {
		_, _, err := getTemplate(context.Background(), req, plan)
		assert.NotNil(t, err)
	})

	t.Run(""Unmarshal fails"", func(t *testing.T) {
		mockServer.Config.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			io.WriteString(w, ""invalid-json"")
		})
		_, _, err := getTemplate(context.Background(), req, plan)
		assert.NotNil(t, err)
		assert.Contains(t, err.Error(), ""cant read template"")
	})

	t.Run(""Success case"", func(t *testing.T) {
		mockServer.Config.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			template := ombentities.Template{}
			json.NewEncoder(w).Encode(template)
		})
		_, _, err := getTemplate(context.Background(), req, plan)
		assert.Nil(t, err)
	})
}"
"func NewApprovalService(tokenSvc interfaces.ServiceNowAuthSvc, approvalURL string, client *http.Client) interfaces.ApprovalSvc {
	token, err := tokenSvc.GetAuthToken()
	if err != nil {
		logger.L.Error(""Failed to initialise token "", zap.Error(err))
		return nil
	}
	return approvalSvc{authToken: token, approvalURL: approvalURL, client: client}
}","func TestNewApprovalService(t *testing.T) {
	t.Run(""Successfully initializes service"", func(t *testing.T) {
		mockSvc := &mocks.MockAuthSvc{
			GetAuthTokenFn: func() (*entities.AuthToken, error) {
				return &entities.AuthToken{AccessToken: ""testAccessToken""}, nil
			},
		}
		client := &http.Client{}
		svc := NewApprovalService(mockSvc, ""http://test.com/approval"", client)

		assert.NotNil(t, svc, ""Expected service to be initialized"")
	})

	t.Run(""Fails to initialize service"", func(t *testing.T) {
		mockSvc := &mocks.MockAuthSvc{
			GetAuthTokenFn: func() (*entities.AuthToken, error) {
				return nil, errors.New(""token error"")
			},
		}
		client := &http.Client{}
		svc := NewApprovalService(mockSvc, ""http://test.com/approval"", client)

		assert.Nil(t, svc)
	})
}"
"func (base BaseController) IsLive() bool {
	return DefaultIsLive()
}","func TestIsLive(t *testing.T) {
	originalDefaultIsLive := DefaultIsLive
	defer func() {
		DefaultIsLive = originalDefaultIsLive
	}()
	base := BaseController{}
	t.Run(""DefaultIsLive returns true"", func(t *testing.T) {
		DefaultIsLive = func() bool { return true }
		assert.True(t, base.IsLive())
	})

	t.Run(""DefaultIsLive returns false"", func(t *testing.T) {
		DefaultIsLive = func() bool { return false }
		assert.False(t, base.IsLive())
	})
}"
"func (m MockJiraSvc) CreateIssueFromResponse(ctx context.Context, request *entities.IssueRequest) (*entities.ResponseIssue, error) {
	if m.CreateIssueFromResponseFn != nil {
		return m.CreateIssueFromResponseFn(ctx, request)
	}
	return nil, nil
}","func TestCreateIssueFromResponse(t *testing.T) {
	issueResponse := entities.IssueRequest{
		TenantID:         tenantID,
		HostingPlatform:  ""MDP"",
		EnvironmentClass: ""PROD"",
		HostRegion:       ""WESTEUROPE"",
		HostEnvironment:  ""PROD1"",
		SpecPlan:         specPlan,
		SpecUser:         ""sampleuser23aug01"",
		SpecDatabase:     ""sampledb23aug01"",
		ApplicationName:  ""sample-1"",
		ApplicationCode:  ""sample-1"",
		ZoneEnvironment:  ""PROD1"",
		ZoneRegion:       ""WESTEUROPE"",
		RequestType:      string(ombentities.TaskClassProvisioning),
	}
	t.Run(""when issueRequest is nil"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		responseIssue, err := jiraSvc.CreateIssueFromResponse(ctx, nil)
		assert.Nil(t, responseIssue)
		assert.NotNil(t, err)
		expectedError := ""issue request is missing""
		assert.EqualError(t, err, expectedError)
	})
	t.Run(""client is not initialised"", func(t *testing.T) {
		jiraSvc := jiraSvc{client: nil}
		responseIssue, err := jiraSvc.CreateIssueFromResponse(ctx, &issueResponse)
		assert.Nil(t, responseIssue)
		expectedError := ""client is not initialised""
		assert.NotNil(t, err)
		assert.EqualError(t, err, expectedError)
	})
	t.Run(""CreateIssue fails"", func(t *testing.T) {
		ss := mock.NewMockSecretStore(mock.WithGetSecret(func(ctx context.Context, key string) (string, error) { return ""bghssdyuun"", nil }))
		jiraSvc, _ := New(ctx, ss, JiraConf, &utilStruct)
		responseIssue, err := jiraSvc.CreateIssueFromResponse(ctx, &issueResponse)
		assert.Nil(t, responseIssue)
		assert.NotNil(t, err)
		expectedErr := ""some error""
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(""all well scenario"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return ""https://localhost:9000/create/issue"", nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		issueResp, err := jiraSvc.CreateIssueFromResponse(ctx, &issueResponse)
		assert.Nil(t, err)
		assert.NotNil(t, issueResp)
		responseIssue := new(entities.ResponseIssue)
		err = json.Unmarshal(body, &responseIssue)
		assert.NoError(t, err)
		assert.Equal(t, responseIssue, issueResp)
	})
	t.Run(""request.HostingPlatform is missing"", func(t *testing.T) {
		ss := mock.NewMockSecretStore(mock.WithGetSecret(func(ctx context.Context, key string) (string, error) { return ""bghssdyuun"", nil }))
		jiraSvc, _ := New(ctx, ss, JiraConf, &utilStruct)
		issueResponse.HostingPlatform = """"
		responseIssue, err := jiraSvc.CreateIssueFromResponse(ctx, &issueResponse)
		assert.Nil(t, responseIssue)
		assert.NotNil(t, err)
		expectedErr := ""hosting information is missing for source type:""
		assert.EqualError(t, err, expectedErr)
	})
}"
"func (svc regionSvc) GetRegions(ctx context.Context) (map[string]interface{}, error) {
	ctx, span := svc.tracer.Start(ctx, ""GetRegions"")
	defer span.End()
	if svc.repo == nil {
		return nil, errors.New(""no store available"")
	}
	regionsList, err := svc.repo.FetchRegions(ctx)
	if err != nil {
		return nil, err
	}
	return regionsList, err
}","func TestGetRegions(t *testing.T) {
	var (
		svc          interfaces.RegionService
		repo         interfaces.RegionRepository
		regions      map[string]interface{}
		someError    = errors.New(""some error"")
		ctx          context.Context
		err          error
		cloudRegions map[string]interface{} = map[string]interface{}{""azure:azure-eastaisa"": """", ""azure:azure-india-central"": """"}
	)

	//nil repo
	svc = NewServiceFactory().WithTracer(testTracer).Finalize()
	assert.NotNil(t, svc)
	//should give err if accessed
	_, err = svc.GetRegions(ctx)
	assert.NotNil(t, err)
	//use a mock repository
	repo = mocks.MockRegionRepository{FetchRegionsFn: func(ctx context.Context) (map[string]interface{}, error) {
		return map[string]interface{}{""azure:azure-eastaisa"": """", ""azure:azure-india-central"": """"}, nil
	}}
	svc = NewServiceFactory().WithRepository(repo).WithTracer(testTracer).Finalize()
	assert.NotNil(t, svc)
	regions, err = svc.GetRegions(ctx)
	assert.Nil(t, err)
	assert.Equal(t, len(regions), len(cloudRegions))
	//use mock Repository with error
	repo = mocks.MockRegionRepository{FetchRegionsFn: func(ctx context.Context) (map[string]interface{}, error) {
		return nil, someError
	}}
	svc = NewServiceFactory().WithRepository(repo).WithTracer(testTracer).Finalize()
	assert.NotNil(t, svc)
	regions, err = svc.GetRegions(ctx)
	assert.NotNil(t, err)
	assert.Nil(t, regions)
}"
"func NewAdmiralService(ext interfaces.ExternalRGService) interfaces.ResourceGroupService {
	return resourcegroup.New(ext)
}","func TestNewAdmiralService(t *testing.T) {
	t.Run(""returns a valid ResourceGroupService"", func(t *testing.T) {
		mockExtRGService := &mockExternalRGService{}
		service := NewAdmiralService(mockExtRGService)
		assert.NotNil(t, service)
		assert.Implements(t, (*interfaces.ResourceGroupService)(nil), service)
	})
}"
"func WriteResponse(writer http.ResponseWriter, msg StandardResponse) {
	writer.WriteHeader(msg.StatusCode)
	m, err := json.Marshal(msg.Payload)
	if err != nil {
		logger.L.Error(""error marshalling response json"", zap.Error(err))
	}
	if _, err = writer.Write(m); err != nil {
		logger.L.Error(""error writing response"", zap.Error(err))
	}
}","func TestWriteResponse(t *testing.T) {
	t.Run(""Valid Payload"", func(t *testing.T) {
		payload := map[string]string{""message"": ""Success""}
		response := StandardResponse{
			StatusCode: http.StatusOK,
			Payload:    payload,
		}
		expectedResponseBody, _ := json.Marshal(payload)
		rr := httptest.NewRecorder()
		WriteResponse(rr, response)
		assert.Equal(t, http.StatusOK, rr.Code)
		assert.JSONEq(t, string(expectedResponseBody), rr.Body.String())
	})

	t.Run(""Marshalling Error"", func(t *testing.T) {
		payload := make(chan int)
		response := StandardResponse{
			StatusCode: http.StatusInternalServerError,
			Payload:    payload,
		}
		rr := httptest.NewRecorder()
		WriteResponse(rr, response)
		assert.Equal(t, http.StatusInternalServerError, rr.Code)
		assert.Empty(t, rr.Body.String())
	})

	t.Run(""Write Error"", func(t *testing.T) {
		payload := map[string]string{""message"": ""Failure""}
		response := StandardResponse{
			StatusCode: http.StatusInternalServerError,
			Payload:    payload,
		}
		mockWriter := &mocks.MockResponseWriter{
			WriteErr: errors.New(""write error""),
		}
		WriteResponse(mockWriter, response)
		assert.Equal(t, http.StatusInternalServerError, mockWriter.Status)
	})
}"
"func StatusToMap(status IssueStatus) string {
	if str, ok := statusMap[status]; ok {
		return str
	}
	return ""Unknown State""
}","func TestStatusToMap(t *testing.T) {
	t.Run(""ToDo Status"", func(t *testing.T) {
		status := StatusToMap(ToDo)
		assert.Equal(t, ""11"", status)
	})
	t.Run(""InProgress Status"", func(t *testing.T) {
		status := StatusToMap(InProgress)
		assert.Equal(t, ""21"", status)
	})
	t.Run(""Done Status"", func(t *testing.T) {
		status := StatusToMap(Done)
		assert.Equal(t, ""31"", status)
	})
	t.Run(""Failed Status"", func(t *testing.T) {
		status := StatusToMap(Failed)
		assert.Equal(t, ""2"", status)
	})
	t.Run(""Unknown Status"", func(t *testing.T) {
		status := StatusToMap(""Unknown Status"")
		assert.Equal(t, ""Unknown State"", status)
	})
}"
"func (c controller) GetPlansV1(ctx context.Context, request oas.GetPlansV1RequestObject) (oas.GetPlansV1ResponseObject, error) {
	return oas.GetPlansV1200JSONResponse([]oas.PlanV1{
		{Name: ""postgres-on-vm""},
	}), nil
}","func TestGetPlansV1(t *testing.T) {
	ctx := context.Background()
	controller := NewFactory().Finalize()

	expectedResponse := oas.GetPlansV1200JSONResponse([]oas.PlanV1{
		{Name: ""postgres-on-vm""},
	})

	response, err := controller.GetPlansV1(ctx, oas.GetPlansV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, expectedResponse, response)
}"
"func LoadAPIConfig(path string) error {
	fileData, err := LoadConfigData(path)
	if err != nil {
		return err
	}
	conf, err := readAllConfigData(fileData)
	if err != nil {
		return err
	}
	logger.L.Info(""config details"", zap.Any(""config"", conf))
	APICfg = &conf.API
	return nil
}","func TestLoadAPIConfig(t *testing.T) {
	t.Run(""Success"", func(t *testing.T) {
		config := API{
			DB: appcfg.Database{
				Host:         ""localhost"",
				Port:         5432,
				User:         ""user"",
				Password:     ""password"",
				DatabaseName: ""dbname"",
				SSLMode:      ""disable"",
			},
			ServerPort:  8080,
			MetricsPort: 9090,
			LogLevel:    ""info"",
			CORSOrigin:  ""*"",
			OpenTelemetry: appcfg.OpenTelemetry{
				ServiceName:      ""service"",
				Endpoint:         ""http://localhost:4317"",
				MetricsPort:      55680,
				TimeoutInSeconds: 30,
				Attributes: map[string]string{
					""key1"": ""value1"",
				},
			},
			JWT: JWT{
				Audience: []string{},
			},
			MTTS: MTTS{
				AllowedTeams: []string{}, // Initialize as an empty slice
			},
		}

		configData, err := yaml.Marshal(config)
		assert.NoError(t, err)

		tmpFile, err := os.CreateTemp("""", ""testconfig*.yaml"")
		assert.NoError(t, err)

		defer os.Remove(tmpFile.Name())

		_, err = tmpFile.Write([]byte(configData))
		assert.NoError(t, err)

		err = tmpFile.Close()
		assert.NoError(t, err)

		err = LoadAPIConfig(tmpFile.Name())
		assert.NoError(t, err)

		expectedConfig := &config
		// Handle nil and empty slice comparison
		if reflect.DeepEqual(expectedConfig.MTTS.AllowedTeams, []string{}) && expectedConfig.MTTS.AllowedTeams == nil {
			expectedConfig.MTTS.AllowedTeams = []string{}
		}
		assert.Equal(t, expectedConfig, APICfg, ""The configuration should be loaded correctly"")

	})

	t.Run(""File Not Found"", func(t *testing.T) {
		err := LoadAPIConfig(""nonexistent.yaml"")
		assert.Error(t, err)
	})

	t.Run(""Invalid YAML"", func(t *testing.T) {
		configData := `
		db:
		  host: ""localhost""
		  port: 5432
		  user: ""user""
		  password: ""password""
		  database_name: ""dbname""
		  ssl_mode: ""disable""
		server_port: 8080
		metrics_port: 9090
		log_level: ""info""
		cors_origin: ""*""
		open_telemetry:
		  service_name: ""service""
		  endpoint: ""http://localhost:4317
		  metrics_port: 55680
		  timeout_in_seconds: 30
		  attributes:
		    key1: ""value1""`

		tmpFile, err := os.CreateTemp("""", ""testconfig*.yaml"")
		assert.NoError(t, err)

		defer os.Remove(tmpFile.Name())

		_, err = tmpFile.Write([]byte(configData))
		assert.NoError(t, err)

		err = tmpFile.Close()
		assert.NoError(t, err)

		err = LoadAPIConfig(tmpFile.Name())
		assert.Error(t, err)
	})
}"
"func TransformResources(arr []provent.Resource) []Resource {
	var ret []Resource
	for _, t := range arr {
		ret = append(ret, TransformResource(t))
	}
	return ret
}","func TestTransformResources(t *testing.T) {
	res := TransformResources([]provent.Resource{
		{
			ID:           ""sample"",
			Orchestrator: ""orca"",
			Region:       ""eu-west"",
		},
		{
			ID:           ""another"",
			Orchestrator: ""orcb"",
			Region:       ""eu-east"",
		},
	})
	assert.Equal(t, 2, len(res))
	assert.Equal(t, ""sample"", res[0].ID)
	assert.Equal(t, ""orca"", res[0].Metadata.Orchestrator)
	assert.Equal(t, ""eu-west"", res[0].Metadata.Hosting.Region.Name)
	assert.Equal(t, ""another"", res[1].ID)
	assert.Equal(t, ""orcb"", res[1].Metadata.Orchestrator)
	assert.Equal(t, ""eu-east"", res[1].Metadata.Hosting.Region.Name)
	res = TransformResources([]provent.Resource{})
	assert.Equal(t, 0, len(res))
	res = TransformResources(nil)
	assert.Equal(t, 0, len(res))
}"
"func (c controller) CreateApplicationResourceV1(ctx context.Context, request oas.CreateApplicationResourceV1RequestObject) (oas.CreateApplicationResourceV1ResponseObject, error) {
	action := ""PostCreateApplicationResourceV1""
	requestComplete := metrics.TrackActiveRequests(action)
	defer requestComplete()
	if c.svc == nil {
		metrics.TrackHttpRequestsTransactions(""POST"", strconv.Itoa(http.StatusBadRequest), action)
		metrics.NumErrorRequests.Inc()
		logger.L.ErrorCtx(ctx, ""can't create resource"", zap.Error(errors.New(""controller has no svc"")))
		return oas.CreateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
			BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusBadRequest,
				Detail:   ""Can't process due to internal server error."",
				Instance: ""/applications/{applicationCode}/resources/v1"",
			},
		}, nil
	}

	if request.Body == nil {
		metrics.TrackHttpRequestsTransactions(""POST"", strconv.Itoa(http.StatusBadRequest), action)
		return oas.CreateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
			BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusBadRequest,
				Detail:   ""Can't process due to bad/missing data."",
				Instance: ""/applications/{applicationCode}/resources/v1"",
			},
		}, nil
	}
	spec, err := request.Body.Spec.AsPostgresResourceSpecV1()
	if err != nil {
		metrics.TrackHttpRequestsTransactions(""POST"", strconv.Itoa(http.StatusBadRequest), action)
		return oas.CreateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
			BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusBadRequest,
				Detail:   ""Can't process due to bad/missing data."",
				Instance: ""/applications/{applicationCode}/resources/v1"",
			},
		}, nil
	}
	if spec.Zone.Environment == nil || spec.Zone.Region == nil {
		metrics.TrackHttpRequestsTransactions(""POST"", strconv.Itoa(http.StatusBadRequest), action)
		return oas.CreateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
			BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusBadRequest,
				Detail:   ""Can't process due to bad/missing data."",
				Instance: ""/applications/{applicationCode}/resources/v1"",
			},
		}, nil
	}
	source := provent.DefaultSource
	if spec.Source != nil {
		source = *spec.Source
	}
	ticketID := """"
	if spec.JiraTicketId != nil {
		ticketID = *spec.JiraTicketId
	}
	req, err := c.svc.AddResource(ctx, provent.Resource{
		Name:             spec.Plan,
		TenantID:         request.ApplicationCode,
		Environment:      *spec.Zone.Environment,
		EnvironmentClass: ombentities.EnvironmentClass(request.Body.EnvironmentClass),
		Region:           *spec.Zone.Region,
		Source:           source,
		JIRATicketID:     ticketID,
		Payload: ombentities.Msi{
			""name"":                              spec.Plan,
			provent.DatabaseNameKey.String():    spec.Database,
			provent.UserNameKey.String():        spec.User,
			provent.ApplicationNameKey.String(): request.ApplicationCode,
		},
	}, nil)
	if err != nil {
		metrics.NumErrorRequests.Inc()
		logger.L.ErrorCtx(ctx, ""cant create request"", zap.Error(err))
		metrics.TrackHttpRequestsTransactions(""POST"", strconv.Itoa(http.StatusBadRequest), action)
		return oas.CreateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
			BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusBadRequest,
				Detail:   createResourceErrorDetail,
				Instance: ""/applications/{applicationCode}/resources/v1"",
			},
		}, nil
	}

	metrics.TrackHttpRequestsTransactions(""POST"", strconv.Itoa(http.StatusAccepted), action)
	return oas.CreateApplicationResourceV1202JSONResponse(views.TransformOASPGResource(req)), nil
}","func TestCreateApplicationResourceV1(t *testing.T) {
	ctx := context.Background()
	oneStr := ""one""
	someErr := errors.New(""some error"")
	errResponse := oas.CreateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
		BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
			Title:    ""Service failed"",
			Status:   http.StatusBadRequest,
			Detail:   ""Can't process due to internal server error."",
			Instance: ""/applications/{applicationCode}/resources/v1"",
		},
	}
	successResponse := oas.CreateApplicationResourceV1202JSONResponse(views.TransformOASPGResource(provent.Resource{ID: ""two"", TenantID: ""one""}))
	controller := NewFactory().Finalize()
	assert.NotNil(t, controller)
	response, err := controller.CreateApplicationResourceV1(ctx, oas.CreateApplicationResourceV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
	controller = NewFactory().WithProviaSvc(nil).Finalize()
	response, err = controller.CreateApplicationResourceV1(ctx, oas.CreateApplicationResourceV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
	controller = NewFactory().WithProviaSvc(mocks.MockProviaSvc{
		AddResourceFn: func(ctx context.Context, provRequest provent.Resource) (provent.Resource, error) {
			return provent.Resource{}, someErr
		},
	}).Finalize()
	errResponse = oas.CreateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
		BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
			Title:    ""Service failed"",
			Status:   http.StatusBadRequest,
			Detail:   ""Can't process due to bad/missing data."",
			Instance: ""/applications/{applicationCode}/resources/v1"",
		},
	}
	response, err = controller.CreateApplicationResourceV1(ctx, oas.CreateApplicationResourceV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
	controller = NewFactory().WithProviaSvc(mocks.MockProviaSvc{
		AddResourceFn: func(ctx context.Context, provRequest provent.Resource) (provent.Resource, error) {
			return provent.Resource{ID: ""two"", TenantID: ""one""}, nil
		},
	}).Finalize()
	response, err = controller.CreateApplicationResourceV1(ctx, oas.CreateApplicationResourceV1RequestObject{ApplicationCode: ""one""})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
	controller = NewFactory().WithProviaSvc(mocks.MockProviaSvc{
		AddResourceFn: func(ctx context.Context, provRequest provent.Resource) (provent.Resource, error) {
			return provent.Resource{ID: ""two"", TenantID: ""one""}, nil
		},
	}).Finalize()
	response, err = controller.CreateApplicationResourceV1(ctx, oas.CreateApplicationResourceV1RequestObject{
		ApplicationCode: ""one"",
		Body:            nil,
	})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
	controller = NewFactory().WithProviaSvc(mocks.MockProviaSvc{
		AddResourceFn: func(ctx context.Context, provRequest provent.Resource) (provent.Resource, error) {
			return provent.Resource{}, someErr
		},
	}).Finalize()
	body := oas.ApplicationResourceV1(views.TransformOASPGResource(provent.Resource{
		Environment: ""PROD"",
		Region:      ""westeurope"",
		TenantID:    ""one"",
	}))
	errResponse = oas.CreateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
		BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
			Title:    ""Service failed"",
			Status:   http.StatusBadRequest,
			Detail:   createResourceErrorDetail,
			Instance: ""/applications/{applicationCode}/resources/v1"",
		},
	}
	response, err = controller.CreateApplicationResourceV1(ctx, oas.CreateApplicationResourceV1RequestObject{
		ApplicationCode: ""one"",
		Body:            &body,
	})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
	controller = NewFactory().WithProviaSvc(mocks.MockProviaSvc{
		AddResourceFn: func(ctx context.Context, provRequest provent.Resource) (provent.Resource, error) {
			return provent.Resource{ID: ""two"", TenantID: ""one""}, nil
		},
	}).Finalize()
	body = oas.ApplicationResourceV1(views.TransformOASPGResource(provent.Resource{
		Environment:  ""PROD"",
		Region:       ""westeurope"",
		TenantID:     ""one"",
		Source:       ""MDP"",
		JIRATicketID: ""some"",
	}))
	response, err = controller.CreateApplicationResourceV1(ctx, oas.CreateApplicationResourceV1RequestObject{
		ApplicationCode: ""one"",
		Body:            &body,
	})
	assert.Nil(t, err)
	assert.Equal(t, successResponse, response)
	wrongSpec := oas.ApplicationResourceSpecV1{}
	wrongSpec.AsPostgresResourceSpecV1()
	wrongdata := oas.ApplicationResourceV1{
		EnvironmentClass: oas.EnvironmentClassV1(""PROD""),
		Id:               &oneStr,
		Spec:             wrongSpec,
		Status: &oas.ResourceStatusV1{
			CreatedDate: time.Now(),
		},
	}
	errResponse = oas.CreateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
		BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
			Title:    ""Service failed"",
			Status:   http.StatusBadRequest,
			Detail:   ""Can't process due to bad/missing data."",
			Instance: ""/applications/{applicationCode}/resources/v1"",
		},
	}
	response, err = controller.CreateApplicationResourceV1(ctx, oas.CreateApplicationResourceV1RequestObject{
		ApplicationCode: ""one"",
		Body:            &wrongdata,
	})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
	wrongSpecPG := oas.PostgresResourceSpecV1{
		Zone: oas.ZoneV1{
			Environment: nil,
		},
	}
	wrongSpec.FromPostgresResourceSpecV1(wrongSpecPG)
	wrongdata = oas.ApplicationResourceV1{
		EnvironmentClass: oas.EnvironmentClassV1(""PROD""),
		Id:               &oneStr,
		Spec:             wrongSpec,
		Status: &oas.ResourceStatusV1{
			CreatedDate: time.Now(),
		},
	}
	response, err = controller.CreateApplicationResourceV1(ctx, oas.CreateApplicationResourceV1RequestObject{
		ApplicationCode: ""one"",
		Body:            &wrongdata,
	})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
}"
"func TransformOASPGResources(resources []provent.Resource) []oas.ApplicationResourceV1 {
	retVal := []oas.ApplicationResourceV1{}
	for _, resource := range resources {
		retVal = append(retVal, TransformOASPGResource(resource))
	}
	return retVal
}","func TestTransformOASPGResources(t *testing.T) {
	resource1 := provent.Resource{
		ID:               ""resource-1"",
		Name:             ""example_plan1"",
		Environment:      ""prod"",
		Region:           ""us-west-1"",
		EnvironmentClass: ""production"",
		State:            3,
		Message:          ""Resource created successfully"",
		Payload: provmsi.Msi{
			provent.DatabaseNameKey.String(): ""example_db1"",
			""name"":                           ""example_plan1"",
			provent.UserNameKey.String():     ""example_user1"",
		},
		Outputs: provmsi.Msi{
			""output_key"": ""output_value1"",
		},
		CreatedAt: time.Now(),
	}

	resource2 := provent.Resource{
		ID:               ""resource-2"",
		Name:             ""example_plan2"",
		Environment:      ""dev"",
		Region:           ""us-west-2"",
		EnvironmentClass: ""development"",
		State:            7,
		Message:          ""Resource in progress"",
		Payload: provmsi.Msi{
			provent.DatabaseNameKey.String(): ""example_db2"",
			""name"":                           ""example_plan2"",
			provent.UserNameKey.String():     ""example_user2"",
		},
		Outputs: provmsi.Msi{
			""output_key"": ""output_value2"",
		},
		CreatedAt: time.Now(),
	}

	resource3 := provent.Resource{
		ID:               ""resource-3"",
		Name:             ""example_plan3"",
		Environment:      ""qa"",
		Region:           ""us-east-1"",
		EnvironmentClass: ""qa"",
		State:            5,
		Message:          ""Resource creation failed"",
		Payload: provmsi.Msi{
			provent.DatabaseNameKey.String(): ""error"",
			""name"":                           ""example_plan3"",
			provent.UserNameKey.String():     ""example_user3"",
		},
		Outputs: provmsi.Msi{
			""output_key"": ""output_value3"",
		},
		CreatedAt: time.Now(),
	}

	resources := []provent.Resource{resource1, resource2, resource3}

	str := """"
	spec := oas.PostgresResourceSpecV1{
		Database: extractStr(resource1.Payload[provent.DatabaseNameKey.String()]),
		Plan:     extractStr(resource1.Payload[""name""]),
		User:     extractStr(resource1.Payload[provent.UserNameKey.String()]),
		Zone: oas.ZoneV1{
			Environment: &resource1.Environment,
			Region:      &resource1.Region,
		},
		Outputs:      (*map[string]interface{})(&resource1.Outputs),
		JiraTicketId: &str,
		Source:       &str,
	}
	retspec := oas.ApplicationResourceSpecV1{}
	if err := retspec.FromPostgresResourceSpecV1(spec); err != nil {
		logger.L.Warn(""couldnt transform resource spec"", zap.Error(err))
	}

	spec1 := oas.PostgresResourceSpecV1{
		Database: extractStr(resource2.Payload[provent.DatabaseNameKey.String()]),
		Plan:     extractStr(resource2.Payload[""name""]),
		User:     extractStr(resource2.Payload[provent.UserNameKey.String()]),
		Zone: oas.ZoneV1{
			Environment: &resource2.Environment,
			Region:      &resource2.Region,
		},
		Outputs:      (*map[string]interface{})(&resource2.Outputs),
		JiraTicketId: &str,
		Source:       &str,
	}
	retspec1 := oas.ApplicationResourceSpecV1{}
	if err := retspec1.FromPostgresResourceSpecV1(spec1); err != nil {
		logger.L.Warn(""couldnt transform resource spec"", zap.Error(err))
	}

	spec2 := oas.PostgresResourceSpecV1{
		Database: extractStr(resource3.Payload[provent.DatabaseNameKey.String()]),
		Plan:     extractStr(resource3.Payload[""name""]),
		User:     extractStr(resource3.Payload[provent.UserNameKey.String()]),
		Zone: oas.ZoneV1{
			Environment: &resource3.Environment,
			Region:      &resource3.Region,
		},
		Outputs:      (*map[string]interface{})(&resource3.Outputs),
		JiraTicketId: &str,
		Source:       &str,
	}
	retspec2 := oas.ApplicationResourceSpecV1{}
	if err := retspec2.FromPostgresResourceSpecV1(spec2); err != nil {
		logger.L.Warn(""couldnt transform resource spec"", zap.Error(err))
	}

	expected := []oas.ApplicationResourceV1{
		{
			EnvironmentClass: oas.EnvironmentClassV1(resource1.EnvironmentClass),
			Id:               &resource1.ID,
			Spec:             retspec,
			Status: &oas.ResourceStatusV1{
				CreatedDate:      resource1.CreatedAt,
				LastModifiedDate: resource1.UpdatedAt,
				StateCode:        oas.COMPLETED,
				StateMessage:     resource1.Message,
			},
		},
		{
			EnvironmentClass: oas.EnvironmentClassV1(resource2.EnvironmentClass),
			Id:               &resource2.ID,
			Spec:             retspec1,
			Status: &oas.ResourceStatusV1{
				CreatedDate:      resource2.CreatedAt,
				LastModifiedDate: resource2.UpdatedAt,
				StateCode:        oas.RUNNING,
				StateMessage:     resource2.Message,
			},
		},
		{
			EnvironmentClass: oas.EnvironmentClassV1(resource3.EnvironmentClass),
			Id:               &resource3.ID,
			Spec:             retspec2,
			Status: &oas.ResourceStatusV1{
				CreatedDate:      resource3.CreatedAt,
				LastModifiedDate: resource3.UpdatedAt,
				StateCode:        oas.FAILED,
				StateMessage:     resource3.Message,
			},
		},
	}
	actual := TransformOASPGResources(resources)
	// Assert the result
	assert.Equal(t, len(expected), len(actual))
	for i := range expected {
		// if !reflect.DeepEqual(actual, expected) {
		// 	t.Errorf(""TransformOASPGResource() = %v, want %v"", actual[i], expected[i])
		// }

		assert.True(t, reflect.DeepEqual(actual, expected))
		assert.Equal(t, expected[i].EnvironmentClass, actual[i].EnvironmentClass)
		assert.Equal(t, expected[i].Id, actual[i].Id)
		assert.Equal(t, expected[i].Spec.ResourceType, actual[i].Spec.ResourceType)
		assert.Equal(t, expected[i].Status.CreatedDate, actual[i].Status.CreatedDate)
		assert.Equal(t, expected[i].Status.LastModifiedDate, actual[i].Status.LastModifiedDate)
		assert.Equal(t, expected[i].Status.StateCode, actual[i].Status.StateCode)
		assert.Equal(t, expected[i].Status.StateMessage, actual[i].Status.StateMessage)
	}
}"
"func (p *PostgresOnVM) RequireKV() bool {
	return true
}","func TestRequireKV(t *testing.T) {
	postgres := &PostgresOnVM{}

	result := postgres.RequireKV()
	assert.True(t, result, ""RequireKV should return true"")
}"
"func (svc envSvc) GetEnvironments(ctx context.Context) (map[string]string, error) {
	if svc.repo == nil {
		return nil, errors.New(""environment repo is not initialised"")
	}
	environments, err := svc.repo.FetchEnvironments(ctx)
	if err != nil {
		return nil, err
	}
	return environments, nil
}","func TestGetEnvironments(t *testing.T) {
	var (
		repo         interfaces.EnvironmentRepository
		svc          interfaces.EnvironmentService
		envMap       map[string]string = map[string]string{""PROD"": ""Production"", ""DEV"": ""Development"", ""TEST"": ""Test""}
		err          error
		expectedErr  error = errors.New(""environment repo is not initialised"")
		environments map[string]string
	)
	svc = NewServiceFactory().Finalize()
	assert.NotNil(t, svc)
	_, err = svc.GetEnvironments(context.Background())
	assert.NotNil(t, err)
	assert.Error(t, expectedErr)
	// Use Mock Repository
	repo = mocks.MockEnvironmentRepository{FetchEnvironmentsFn: func(ctx context.Context) (map[string]string, error) {
		return envMap, nil
	}}
	svc = NewServiceFactory().WithRepository(repo).Finalize()
	assert.NotNil(t, svc)
	environments, err = svc.GetEnvironments(context.Background())
	assert.NotNil(t, environments)
	assert.Nil(t, err)
	assert.Equal(t, 3, len(environments))

	// Use Mock Repository with error
	repo = mocks.MockEnvironmentRepository{FetchEnvironmentsFn: func(ctx context.Context) (map[string]string, error) {
		return nil, errors.New(""some error"")
	}}
	svc = NewServiceFactory().WithRepository(repo).Finalize()
	assert.NotNil(t, svc)
	environments, err = svc.GetEnvironments(context.Background())
	assert.Nil(t, environments)
	assert.NotNil(t, err)
	assert.Error(t, errors.New(""some error""))

}"
"func (m MockHttpClient) NewRequest(ctx context.Context, method string, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
	if m.NewRequestFn != nil {
		return m.NewRequestFn(ctx, method, urlStr, body, reqHeaders)
	}
	return nil, nil
}","func TestNewRequest(t *testing.T) {
	t.Run(""NewRequestFn == nil"", func(t *testing.T) {
		mockClient := MockHttpClient{NewRequestFn: nil}
		req, err := mockClient.NewRequest(ctx, ""Post"", ""https://loclahost:8080"", nil, nil)
		assert.Nil(t, req)
		assert.Nil(t, err)
	})
	t.Run(""NewRequestFn != nil"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			}}
		req, err := mockHttpClient.NewRequest(ctx, ""Post"", ""https://loclahost:8080"", nil, nil)
		assert.NotNil(t, req)
		assert.Nil(t, err)
	})
}"
"func GetArtifact(name, atype string) (string, error) {
	if client == nil {
		return """", errors.New(""manifest service not initialized"")
	}
	url_, err := url.ParseRequestURI(baseURL)
	if err != nil {
		return """", err
	}
	values := url_.Query()
	values.Add(""name"", name)
	values.Add(""type"", atype)
	url_.RawQuery = values.Encode()
	header := http.Header{}
	header.Add(""Content-Type"", ""application/json"")
	resp, err := client.Do(&http.Request{
		Method: http.MethodGet,
		URL:    url_,
		Header: header,
	})
	if err != nil {
		return """", fmt.Errorf(""cant fetch artifact: %w"", err)
	}
	defer resp.Body.Close()
	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return """", fmt.Errorf(""cant read fetched artifact: %w"", err)
	}
	f, err := os.CreateTemp("""", fmt.Sprintf(""%s.*"", name))
	if err != nil {
		return """", fmt.Errorf(""couldnt create temp artifact: %w"", err)
	}
	defer f.Close()
	tempFiles = append(tempFiles, f.Name())
	if _, err = f.Write(data); err != nil {
		return """", fmt.Errorf(""couldnt write temp artifact: %w"", err)
	}
	return f.Name(), nil
}","func TestGetArtifact(t *testing.T){
	t.Run(""get artifact uninitalized"", func(t *testing.T){
		client = nil
		_, err := GetArtifact(""test"", ""type"")
		assert.Error(t, err)
		assert.Equal(t, ""manifest service not initialized"", err.Error())
	})

	t.Run(""get artifact success"", func(t *testing.T){
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			assert.Equal(t, ""/?name=test&type=type"", r.URL.String())
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(""artifact data""))
		}))
		defer server.Close()
	
		cfg := appcfg.ExternalService{
			URL: server.URL,
		}
		err := Initialize(cfg)
		assert.NoError(t, err)
		tempFileName, err := GetArtifact(""test"", ""type"")
		assert.NoError(t, err)
		assert.FileExists(t, tempFileName)
		defer os.Remove(tempFileName)
	})

	t.Run(""read error while get artifact is called"", func(t *testing.T){
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(""partial data""))
			w.(http.Flusher).Flush()
			conn, _, _ := w.(http.Hijacker).Hijack()
			conn.Close()
		}))
	
		defer server.Close()
	
		cfg := appcfg.ExternalService{
			URL: server.URL,
		}
		err := Initialize(cfg)
		assert.NoError(t, err)
		_, err = GetArtifact(""test"", ""type"")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), ""cant read fetched artifact"")
	})

	t.Run(""get artifact fetch error"", func(t *testing.T){
		cfg := appcfg.ExternalService{
			URL: ""http://localhost:9999"", 
		}
		err := Initialize(cfg)
		assert.NoError(t, err)
	
		_, err = GetArtifact(""test"", ""type"")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), ""cant fetch artifact"")
	})
}"
"func (r *MockReaderWithError) Read(p []byte) (n int, err error) {
	return 0, r.err // Always return the error
}","func TestRead(t *testing.T) {
	t.Run(testMessage, func(t *testing.T) {
		mockReader := MockReaderWithError{err: errors.New(errMessage), closed: true}
		body := []byte(``)
		size, err := mockReader.Read(body)
		assert.Equal(t, 0, size)
		assert.EqualError(t, err, errMessage)
	})
}"
"func JSONHeadersMiddleware(req *http.Request, accessToken string) *http.Request {
	req.Header.Add(""Accept"", ""application/json"")
	req.Header.Add(""Content-Type"", ""application/json"")
	req.Header.Add(""Authorization"", ""Bearer ""+accessToken)
	return req

}","func TestJSONHeadersMiddleware(t *testing.T) {
	req, _ := http.NewRequest(""GET"", ""https://test.com"", nil)
	accessToken := ""test-token""

	req = JSONHeadersMiddleware(req, accessToken)

	assert.Equal(t, ""application/json"", req.Header.Get(""Accept""))
	assert.Equal(t, ""application/json"", req.Header.Get(""Content-Type""))
	assert.Equal(t, ""Bearer test-token"", req.Header.Get(""Authorization""))
}"
"func GetManifest(id string) ([]byte, error) {
	if client == nil || decoderGen == nil {
		return nil, errors.New(""manifest service not initialized"")
	}
	url_, err := url.ParseRequestURI(fmt.Sprintf(""%s/%s"", baseURL, id))
	if err != nil {
		return nil, err
	}
	header := http.Header{}
	header.Add(""Content-Type"", ""application/json"")
	resp, err := client.Do(&http.Request{
		Method: http.MethodGet,
		URL:    url_,
		Header: header,
	})
	if err != nil {
		return nil, fmt.Errorf(""cant fetch manifest: %w"", err)
	}
	defer resp.Body.Close()
	return io.ReadAll(resp.Body)
}","func TestGetManifest(t *testing.T){
	t.Run(""get manifest when service is not initialized"", func(t *testing.T){
		client = nil
		decoderGen = nil
		_, err := GetManifest(""test-id"")
		assert.Error(t, err, ""Error when manifest service is uninitialized"")
		assert.Equal(t, ""manifest service not initialized"", err.Error())
	})

	t.Run(""get manifest with invaild url"",func(t *testing.T){
			cfg := appcfg.ExternalService{
			URL: ""invalid-url"",
			TimeoutInSeconds: 10,
		}
	
		Initialize(cfg, func(r io.Reader) appinit.Decoder {
			return mockDecoder{}
		})
	
		_, err := GetManifest(""test-id"")
		assert.Error(t, err, ""Error invalid URL"")
	})

	t.Run(""get manifest success"", func(t *testing.T){
		cfg := appcfg.ExternalService{
			URL:""http://test.com"",
			TimeoutInSeconds: 10,
		}
	
		Initialize(cfg, func(r io.Reader) appinit.Decoder {
			return mockDecoder{}
		})
	
		mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			assert.Equal(t, http.MethodGet, r.Method, ""Expected GET method"")
			assert.Equal(t, ""/test-id"", r.URL.Path, ""Expected request to correct URL"")
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{""key"":""value""}`))
		}))
		defer mockServer.Close()
	
		baseURL = mockServer.URL
	
		result, err := GetManifest(""test-id"")
		assert.NoError(t, err, ""Expected no error"")
		assert.NotNil(t, result, ""Expected some result"")
		assert.Equal(t, `{""key"":""value""}`, string(result), ""Expected correct response body"")
	})
}"
"func NewIncidentService(tokenSvc interfaces.ServiceNowAuthSvc, incidentURL string, client *http.Client) interfaces.IncidentSvc {
	token, err := tokenSvc.GetAuthToken()
	if err != nil {
		logger.L.Error(""Failed to initialise token "", zap.Error(err))
		return nil
	}
	return incidentSvc{authToken: token, incidentURL: incidentURL, client: client}
}","func TestNewIncidentService(t *testing.T) {
	t.Run(""Successfully initializes service"", func(t *testing.T) {
		mockAuthSvc := &mocks.MockAuthSvc{
			Token: &entities.AuthToken{AccessToken: ""testToken""},
		}

		mockServer := mockServer(http.StatusOK, []byte(`{""result"": ""success""}`))
		defer mockServer.Close()

		service := NewIncidentService(mockAuthSvc, mockServer.URL+""/incident"", &http.Client{})

		assert.NotNil(t, service)
		assert.Equal(t, ""testToken"", service.(incidentSvc).authToken.AccessToken)
	})

	t.Run(""Fails to initialize service"", func(t *testing.T) {
		service := incidentSvc{}

		_, err := service.GetIncident(nil)
		assert.Equal(t, errIncidentSvcNotInit, err.Error())

		_, err = service.PostIncident([]byte(`{""key"":""value""}`))
		assert.Equal(t, errIncidentSvcNotInit, err.Error())

		_, err = service.PatchIncident([]byte(`{""key"":""value""}`), ""key"", ""value"")
		assert.Equal(t, errIncidentSvcNotInit, err.Error())
	})
}"
"func Initialize(ctx context.Context, r interfaces.UnitRepository, s secint.SecretStore,
	t opentelemetry.OtelTracer, rg rgint.ResourceGroupService, cfg config.Unit) {
	secretStore = s
	tracer = t
	repo = r
	rgSvc = rg
	ombApp = cfg.MSS.OmbApplication
	dbapp = cfg.MSS.DBApplication
	awxTokenURLProd, awxMasterKeyProd = cfg.AWXTokenURLProd, cfg.AWXMasterKeyProd
	awxTokenURLNonProd, awxMasterKeyNonProd = cfg.AWXTokenURLNonProd, cfg.AWXMasterKeyNonProd
	prodlbDetails = cfg.ProdLoadBalancer
	nonprodlbDetails = cfg.NonProdLoadBalancer
	tfprod = cfg.TFProdSPN
	tfnonprod = cfg.TFNonProdSPN
	rgEnvP, rgEnvNP = cfg.RGEnvironmentProd, cfg.RGEnvironmentNonprod
	ombEnv = ombentities.OmnibaseDeploymentName(cfg.OMBEnvCode)
	logger.L.DebugCtx(ctx, ""Omnibase env"", zap.String(""name"", ombEnv))

	initializeMSS(ctx, cfg.MSS.Scope)
}","func TestInitialize(t *testing.T) {
	t.Run(""initialize with a custom timeout"", func(t *testing.T) {
		cfg := appcfg.ExternalService{
			URL:              ""http://test.com"",
			TimeoutInSeconds: 10,
		}

		err := Initialize(cfg)
		assert.NoError(t, err, ""Initialization succeeded with custom timeout"")
		assert.Equal(t, 10*time.Second, client.Timeout, ""Custom timeout applied"")
		assert.Equal(t, ""http://test.com"", baseURL, ""Base URL set correctly"")
	})

	t.Run(""initialize with default timeout"", func(t *testing.T) {
		cfg := appcfg.ExternalService{
			URL: ""http://test.com"",
		}

		err := Initialize(cfg)
		assert.NoError(t, err, ""Initialization succeeded with default timeout"")
		assert.Equal(t, defaultTimeoutInSeconds*time.Second, client.Timeout, ""Default timeout applied"")
		assert.Equal(t, ""http://test.com"", baseURL, ""Base URL set correctly"")
	})
}"
"func (m MockJiraSvc) MarkIssueToDo(ctx context.Context, issueIdorKey string, comment string) error {
	if m.MarkIssueToDoFn != nil {
		return m.MarkIssueToDoFn(ctx, issueIdorKey, comment)
	}
	return nil
}","func TestMarkIssueToDo(t *testing.T) {
	t.Run(idOrKeyMissingMsg, func(t *testing.T) {
		ss := mock.NewMockSecretStore(mock.WithGetSecret(func(ctx context.Context, key string) (string, error) { return ""bghssdyuun"", nil }))
		jiraSvc, _ := New(ctx, ss, JiraConf, nil)
		err := jiraSvc.MarkIssueToDo(ctx, """", ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errIssueIdOrKeyMissing
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(clientMissing, func(t *testing.T) {
		jiraSvc := jiraSvc{client: nil}
		err := jiraSvc.MarkIssueToDo(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errClientNotInitialized
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(commentAddFailureMsg, func(t *testing.T) {
		ss := mock.NewMockSecretStore(mock.WithGetSecret(func(ctx context.Context, key string) (string, error) { return ""bghssdyuun"", nil }))
		jiraSvc, _ := New(ctx, ss, JiraConf, &utilStruct)
		err := jiraSvc.MarkIssueToDo(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(clientReqFailureMsg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return nil, errors.New(errMessage)
		}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		err := jiraSvc.MarkIssueToDo(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(clientDoFailureMsg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{}, []byte(`{""field1"": ""value1"", ""field2"": 42}`), errors.New(errMessage)
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		err := jiraSvc.MarkIssueToDo(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(status204Msg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{StatusCode: 204}, []byte(`{""field1"": ""value1"", ""field2"": 42}`), nil
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		err := jiraSvc.MarkIssueToDo(ctx, issueID121, ""Maersk"")
		assert.Nil(t, err)
	})
	t.Run(statusnot204Msg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{StatusCode: 502}, []byte(`{""field1"": ""value1"", ""field2"": 42}`), errors.New(errMessage)
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		err := jiraSvc.MarkIssueToDo(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
}"
"func GetPlanDecomInterval(id string) (uint16, error) {
	if client == nil {
		return 0, errors.New(""plan service not initialized"")
	}
	url_, err := url.ParseRequestURI(fmt.Sprintf(""%s/%s/decomInterval"", baseURL, id))
	if err != nil {
		return 0, err
	}
	header := http.Header{}
	header.Add(""Content-Type"", ""application/json"")
	resp, err := client.Do(&http.Request{
		Method: http.MethodGet,
		URL:    url_,
		Header: header,
	})
	if err != nil {
		return 0, fmt.Errorf(""cant fetch plan: %w"", err)
	}
	defer resp.Body.Close()
	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return 0, fmt.Errorf(""cant read resp body: %w"", err)
	}
	var intResp struct {
		Interval uint16 `json:""interval""`
	}
	if err = json.Unmarshal(data, &intResp); err != nil {
		return 0, fmt.Errorf(""cant unmarshal response: %w"", err)
	}
	return intResp.Interval, nil
}","func TestGetPlanDecomInterval(t *testing.T) {
	t.Run(""should return error if client is nil"", func(t *testing.T) {
		baseURL = ""http://test.com""
		client = nil 

		_, err := GetPlanDecomInterval(""testid"")
		assert.Error(t, err)
		assert.Equal(t, ""plan service not initialized"", err.Error())
	})

	t.Run(""should return error for invalid URL"", func(t *testing.T) {
		baseURL = ""http://test.com\\invalid-url"" 
		client = &http.Client{}

		_, err := GetPlanDecomInterval(""testid"")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), ""invalid character"")
	})

	t.Run(""should return error for failed HTTP request"", func(t *testing.T) {
		baseURL = ""http://test.com""
		client = &http.Client{
			Transport: roundTripper(func(req *http.Request) (*http.Response, error) {
				return nil, errors.New(""cant fetch plan"")
			}),
		}

		_, err := GetPlanDecomInterval(""testid"")
		assert.Error(t, err)
	})

	t.Run(""should return error for invalid response body"", func(t *testing.T) {
		baseURL = ""http://test.com""
		client = &http.Client{
			Transport: roundTripper(func(req *http.Request) (*http.Response, error) {
				return &http.Response{
					StatusCode: http.StatusOK,
					Body:       io.NopCloser(bytes.NewReader([]byte(""invalid json""))),
				}, nil
			}),
		}

		_, err := GetPlanDecomInterval(""testid"")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), ""cant unmarshal response"")
	})

	t.Run(""should return decom interval on success"", func(t *testing.T) {
		baseURL = ""http://test.com""
		expectedInterval := uint16(15)
		responseBody, _ := json.Marshal(map[string]uint16{""interval"": expectedInterval})

		client = &http.Client{
			Transport: roundTripper(func(req *http.Request) (*http.Response, error) {
				assert.Equal(t, http.MethodGet, req.Method)
				assert.Equal(t, ""application/json"", req.Header.Get(""Content-Type""))
				assert.Equal(t, ""http://test.com/testid/decomInterval"", req.URL.String())

				return &http.Response{
					StatusCode: http.StatusOK,
					Body:       io.NopCloser(bytes.NewReader(responseBody)),
				}, nil
			}),
		}

		interval, err := GetPlanDecomInterval(""testid"")
		assert.NoError(t, err)
		assert.Equal(t, expectedInterval, interval)
	})
}"
"func (d dispatcher) HelmChartInstallNginxHandler(ctx context.Context, req provent.Resource) error {
	logger.L.InfoCtx(ctx, ""received req"", zap.String(""helmInstaller"", req.Name), zap.Any(""req"", req))
	if err := hcaasInvoker(ctx, hcaasOptions{
		driver:    ""memory"",
		location:  ""https://github.com/kubernetes/ingress-nginx/releases/download/helm-chart-4.7.1/ingress-nginx-4.7.1.tgz"",
		release:   ""test01"",
		namespace: ""ngx-test01"",
	}); err != nil {
		logger.L.ErrorCtx(ctx, ""provisioning failed"", zap.Error(err))
		return d.ErrorHandler(ctx)
	}
	req.State = uint(provent.CompletedState)
	return publisher.PublishFeedback(ctx, req)
}","func TestHelmChartInstallNginxHandler(t *testing.T) {
	mockPublisher := mocks.MockPublisher{}
	InitializePublishSvc(mockPublisher)
	mockDispatcher := dispatcher{}

	ctx := context.Background()
	req := provent.Resource{
		Name:  ""testHelmInstaller"",
		State: uint(provent.CompletedState),
	}

	t.Run(""Successful Helm Chart Install"", func(t *testing.T) {
		InitializePublishSvc(mockPublisher)
		err := mockDispatcher.HelmChartInstallNginxHandler(ctx, req)

		assert.NoError(t, err)
		assert.Equal(t, uint(provent.CompletedState), req.State)
	})
}"
"func TransformRegions(cloudRegionMap map[string]interface{}) []cloudRegion {
	var (
		regionEntity region
		retMap       map[string][]region = make(map[string][]region)
	)
	for cloudRegion := range cloudRegionMap {
		crList := strings.Split(cloudRegion, "":"")
		cloud, regionName := crList[0], crList[1]
		regionEntity = region{Name: regionName}
		if _, ok := retMap[cloud]; !ok {
			retMap[cloud] = []region{regionEntity}
		} else {
			retMap[cloud] = append(retMap[cloud], regionEntity)
		}
	}
	return getCloudRegionList(retMap)
}","func TestTransformRegions(t *testing.T) {
	cloudRegions := map[string]interface{}{""azure:azure-eastaisa"": """", ""azure:azure-india-central"": """", ""gcp:google-asia-east1"": """", ""gcp:google-asia-east2"": """", ""gcp:google-asia-northeast1"": """"}
	// When non empty cloudRegionMap is provided
	cloudRegionsList := TransformRegions(cloudRegions)
	assert.NotNil(t, cloudRegionsList)
	assert.Equal(t, 2, len(cloudRegionsList))

	// When  empty cloudRegionMap is provided
	cloudRegionsList2 := TransformRegions(make(map[string]interface{}))
	expected := make([]cloudRegion, 0)
	assert.NotNil(t, cloudRegionsList2)
	assert.Equal(t, expected, cloudRegionsList2)

}"
"func (repo fsRepo) FetchRegions(ctx context.Context) (map[string]interface{}, error) {
	_, span := fileTracer.Start(ctx, ""FetchRegions"")
	defer span.End()
	if len(regions) == 0 {
		return nil, errors.New(""regions list present in file is empty"")
	}
	var retMap map[string]interface{} = regions
	return retMap, nil
}","func TestFetchRegions(t *testing.T) {
	var (
		repo    interfaces.RegionRepository
		ctx     context.Context
		regions map[string]interface{}
		err     error
	)
	//When regionsList is not initialised , and empty json file is passed to read
	repo, _ = New(testdata.TestRegionStore{}, testdata.EmptyJsonFileName, testTracer)
	ctx = context.Background()
	regions, err = repo.FetchRegions(ctx)
	assert.Nil(t, regions)
	assert.NotNil(t, err)

	//When regionsList is not initialised , and empty yaml file is passed to read
	repo, _ = New(testdata.TestRegionStore{}, testdata.EmptyYamlFileName, testTracer)
	regions, err = repo.FetchRegions(ctx)
	assert.Nil(t, regions)
	assert.NotNil(t, err)

	//When regionsList is initialised with valid YAML file
	repo, _ = New(testdata.TestRegionStore{}, testdata.YamlFileName, testTracer)
	regions, err = repo.FetchRegions(ctx)
	assert.NotNil(t, regions)
	assert.Nil(t, err)

	//When regionsList is initialised with valid JSON file
	repo, _ = New(testdata.TestRegionStore{}, testdata.JsonFileName, testTracer)
	regions, err = repo.FetchRegions(ctx)
	assert.NotNil(t, regions)
	assert.Nil(t, err)

}"
"func (svc incidentSvc) GetIncident(params map[string]string) (interface{}, error) {
	if svc.authToken == nil || svc.client == nil {
		return nil, errors.New(errIncidentSvcNotInit)
	}
	req, err := http.NewRequest(http.MethodGet, svc.incidentURL, nil)
	if err != nil {
		logger.L.Error(errFormingReqObj, zap.Error(err))
		return nil, err
	}
	//Build Get URL Query
	query := helper.BuildURLQuery(req, params)
	req.URL.RawQuery = query.Encode()
	logger.L.Info(""Incident URL formed "", zap.Any(""URL"", req.URL.String()))
	req = helper.JSONHeadersMiddleware(req, svc.authToken.AccessToken)
	return helper.HTTPClient(req, svc.client)
}","func TestGetIncident(t *testing.T) {
	t.Run(""Successfully gets incident"", func(t *testing.T) {
		mockAuthSvc := &mocks.MockAuthSvc{
			Token: &entities.AuthToken{AccessToken: ""testToken""},
		}

		mockServer := mockServer(http.StatusOK, []byte(`{""result"": ""success""}`))
		defer mockServer.Close()

		service := NewIncidentService(mockAuthSvc, mockServer.URL+""/incident"", &http.Client{})

		params := map[string]string{""param1"": ""value1""}
		result, err := service.GetIncident(params)

		assert.NoError(t, err)
		assert.NotNil(t, result)
	})

	t.Run(""Fails to get incident due to invalid URL"", func(t *testing.T) {
		mockAuthSvc := &mocks.MockAuthSvc{
			Token: &entities.AuthToken{AccessToken: ""testToken""},
		}

		service := NewIncidentService(mockAuthSvc, ""http://%invalid%url"", &http.Client{})

		params := map[string]string{""key"": ""value""}
		_, err := service.GetIncident(params)

		assert.Error(t, err)
	})
}"
"func (c controller) GetZonesV1(ctx context.Context, request oas.GetZonesV1RequestObject) (oas.GetZonesV1ResponseObject, error) {
	env := ""PROD""
	region := ""WESTEUROPE""
	return oas.GetZonesV1200JSONResponse([]oas.ZoneV1{
		{Environment: &env, Region: &region},
	}), nil
}","func TestGetZonesV1(t *testing.T) {
	ctx := context.Background()
	controller := NewFactory().Finalize()

	expectedResponse := oas.GetZonesV1200JSONResponse([]oas.ZoneV1{
		{Environment: new(string), Region: new(string)},
	})
	*expectedResponse[0].Environment = ""PROD""
	*expectedResponse[0].Region = ""WESTEUROPE""

	response, err := controller.GetZonesV1(ctx, oas.GetZonesV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, expectedResponse, response)
}"
"func NewMockReader(err error) *MockReaderWithError {
	return &MockReaderWithError{err: err}
}","func TestNewMockReader(t *testing.T) {
	t.Run(testMessage, func(t *testing.T) {
		inputError := errors.New(errMessage)
		mockReader := NewMockReader(inputError)
		assert.NotNil(t, mockReader.err)
	})

}"
"func DefaultProber() Prober {
	return BaseController{}
}","func TestDefaultProber(t *testing.T) {
	prober := DefaultProber()
	_, ok := prober.(BaseController)
	assert.True(t, ok)
}"
"func (m MockJiraSvc) ExtractIssueResponse(ctx context.Context, response map[string]interface{}) (*entities.IssueDetails, error) {
	if m.ExtractIssueResponseFn != nil {
		return m.ExtractIssueResponseFn(ctx, response)
	}
	return nil, nil
}","func TestExtractIssueResponse(t *testing.T) {
	t.Run(""response is nil"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		issueDetails, err := jiraSvc.ExtractIssueResponse(ctx, nil)
		assert.Nil(t, issueDetails)
		assert.NotNil(t, err)
		expectedError := ""response is missing""
		assert.EqualError(t, err, expectedError)
	})
	t.Run(""all pass scenario"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
		}
		byteResponse := []byte(`{""issue"":{""id"":""54128"",""key"":""MNBS-99"",""self"":""https://localhost:9000/54128"",""fields"":{""customfield_29847"":""geneva0e45-880b-43b9-b211-8bd4ab209c2c"",""customfield_29848"":""PROD"",""customfield_29850"":""WESTEUROPE"",""customfield_29849"":""PROD1"",""customfield_29852"":""provision-pg-mop-1vm"", ""customfield_29851"":""sampleuserbharat"",""customfield_29854"":""sampledb-bharat"",""customfield_29853"":""sample-1-bharat"",""customfield_29855"":""sample-1-bharat"",""customfield_29856"":""PROD1"",""customfield_29857"":""WESTEUROPE"",""summary"":""Sample summary"",""description"":{
			""version"": 1,
			""type"": ""doc"",
			""content"": [
			  {
				""type"": ""paragraph"",
				""content"": [
				  {
					""type"": ""text"",
					""text"": ""I am Prakhar""
				  }
				]
			  }
			]
		  }}
		}
		}`)
		var data map[string]interface{}
		if err := json.Unmarshal(byteResponse, &data); err != nil {
			t.Errorf(errUnmarshalByteResp)
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		issueDetails, err := jiraSvc.ExtractIssueResponse(ctx, data)
		assert.Nil(t, err)
		assert.NotNil(t, issueDetails)
		expectedIssue := entities.IssueDetails{ID: ""54128"",
			Key:              issueID99,
			Self:             selfURL,
			TenantID:         tenantID,
			HostingPlatform:  """",
			EnvironmentClass: ""PROD"",
			HostRegion:       ""WESTEUROPE"",
			HostEnvironment:  ""PROD1"",
			SpecPlan:         specPlan,
			SpecUser:         ""sampleuserbharat"",
			SpecDatabase:     sampleDB,
			ApplicationName:  appID,
			ApplicationCode:  appID,
			ZoneEnvironment:  ""PROD1"",
			ZoneRegion:       ""WESTEUROPE"",
			ParentKey:        """",
			Description:      "" I am Prakhar"",
			Summary:          sampleSummary,
			ResourceID:       """",
			IssueType:        """"}
		assert.Equal(t, &expectedIssue, issueDetails)
	})

	t.Run(""fails at svc.extractTextFromADF"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
		}
		byteResponse := []byte(`{""issue"": {""fields"":{""description"":{""version"": 1,""type"": ""doc"",""content"": []}}}}`)
		var data map[string]interface{}
		if err := json.Unmarshal(byteResponse, &data); err != nil {
			t.Errorf(errUnmarshalByteResp)
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		issueDetails, err := jiraSvc.ExtractIssueResponse(ctx, data)
		assert.Nil(t, issueDetails)
		assert.NotNil(t, err)
		expectedErr := ""adf content list is missing""
		assert.EqualError(t, err, expectedErr)
	})

	t.Run(""description is of string type"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
		}
		byteResponse := []byte(`{""issue"":{""id"":""54128"",""key"":""MNBS-99"",""self"":""https://localhost:9000/54128"",""fields"":{""customfield_29847"":""geneva0e45-880b-43b9-b211-8bd4ab209c2c"",""customfield_29848"":""PROD"",""customfield_29850"":""WESTEUROPE"",""customfield_29849"":""PROD1"",""customfield_29852"":""provision-pg-mop-1vm"", ""customfield_29851"":""sampleuserbharat"",""customfield_29854"":""sampledb-bharat"",""customfield_29853"":""sample-1-bharat"",""customfield_29855"":""sample-1-bharat"",""customfield_29856"":""PROD1"",""customfield_29857"":""WESTEUROPE"",""summary"":""Sample summary"",""description"":""Some Description""}
		}
		}`)
		var data map[string]interface{}
		if err := json.Unmarshal(byteResponse, &data); err != nil {
			t.Errorf(errUnmarshalByteResp)
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		issueDetails, err := jiraSvc.ExtractIssueResponse(ctx, data)
		assert.Nil(t, err)
		assert.NotNil(t, issueDetails)
		expectedIssue := entities.IssueDetails{ID: ""54128"",
			Key:              issueID99,
			Self:             selfURL,
			TenantID:         tenantID,
			HostingPlatform:  """",
			EnvironmentClass: ""PROD"",
			HostRegion:       ""WESTEUROPE"",
			HostEnvironment:  ""PROD1"",
			SpecPlan:         specPlan,
			SpecUser:         ""sampleuserbharat"",
			SpecDatabase:     sampleDB,
			ApplicationName:  appID,
			ApplicationCode:  appID,
			ZoneEnvironment:  ""PROD1"",
			ZoneRegion:       ""WESTEUROPE"",
			ParentKey:        """",
			Description:      ""Some Description"",
			Summary:          sampleSummary,
			ResourceID:       """",
			IssueType:        """"}
		assert.Equal(t, &expectedIssue, issueDetails)
	})

	t.Run(""convertToStruct in case of description fails due to invalid json error"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
		}
		byteResponse := []byte(`{""issue"":{""id"":""54128"",""key"":""MNBS-99"",""self"":""https://localhost:9000/54128"",""fields"":{""customfield_29847"":""geneva0e45-880b-43b9-b211-8bd4ab209c2c"",""customfield_29848"":""PROD"",""customfield_29850"":""WESTEUROPE"",""customfield_29849"":""PROD1"",""customfield_29852"":""provision-pg-mop-1vm"", ""customfield_29851"":""sampleuserbharat"",""customfield_29854"":""sampledb-bharat"",""customfield_29853"":""sample-1-bharat"",""customfield_29855"":""sample-1-bharat"",""customfield_29856"":""PROD1"",""customfield_29857"":""WESTEUROPE"",""summary"":""Sample summary"",""description"":{
			""version"": ""1"",
			""type"": ""doc"",
			""content"": [
			  {
				""type"": ""paragraph"",
				""content"": [
				  {
					""type"": ""text"",
					""text"": ""I am Prakhar""
				  }
				]
			  }
			]
		  }}
		}
		}`)
		var data map[string]interface{}
		if err := json.Unmarshal(byteResponse, &data); err != nil {
			t.Errorf(errUnmarshalByteResp)
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		issueDetails, err := jiraSvc.ExtractIssueResponse(ctx, data)
		assert.NotNil(t, err)
		assert.Nil(t, issueDetails)
		expectedError := ""json: cannot unmarshal string into Go struct field ADFDocument.version of type int64""
		assert.EqualError(t, err, expectedError)
	})

	t.Run(""failed to unmarshal issueResponse when performing ombentities.ConvertToStruct[entities.IssueResponse](issueDetails) "", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
		}
		byteResponse := []byte(`{""issue"":{""id"":54128,""key"":""MNBS-99"",""self"":""https://localhost:9000/54128"",""fields"":{""customfield_29847"":""geneva0e45-880b-43b9-b211-8bd4ab209c2c"",""customfield_29848"":""PROD"",""customfield_29850"":""WESTEUROPE"",""customfield_29849"":""PROD1"",""customfield_29852"":""provision-pg-mop-1vm"", ""customfield_29851"":""sampleuserbharat"",""customfield_29854"":""sampledb-bharat"",""customfield_29853"":""sample-1-bharat"",""customfield_29855"":""sample-1-bharat"",""customfield_29856"":""PROD1"",""customfield_29857"":""WESTEUROPE"",""summary"":""Sample summary"",""description"":""Some Description""}
		}
		}`)
		var data map[string]interface{}
		if err := json.Unmarshal(byteResponse, &data); err != nil {
			t.Errorf(errUnmarshalByteResp)
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		issueDetails, err := jiraSvc.ExtractIssueResponse(ctx, data)
		assert.Nil(t, issueDetails)
		assert.NotNil(t, err)
		expectedError := ""json: cannot unmarshal number into Go struct field FieldResponse.issue.id of type string""
		assert.EqualError(t, err, expectedError)
	})

	t.Run(""getHostingplatform fails"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
		}
		byteResponse := []byte(`{""issue"":{""id"":""54128"",""key"":""MNBS-99"",""self"":""https://localhost:9000/54128"",""fields"":{""customfield_29847"":""geneva0e45-880b-43b9-b211-8bd4ab209c2c"",""customfield_29848"":""PROD"",""customfield_29850"":""WESTEUROPE"",""customfield_29849"":""PROD1"",""customfield_29852"":""provision-pg-mop-1vm"", ""customfield_29851"":""sampleuserbharat"",""customfield_29854"":""sampledb-bharat"",""customfield_29853"":""sample-1-bharat"",""customfield_29855"":""sample-1-bharat"",""customfield_29856"":""PROD1"",""customfield_29857"":""WESTEUROPE"",""summary"":""Sample summary"",""description"":{
			""version"": 1,
			""type"": ""doc"",
			""content"": [
			  {
				""type"": ""paragraph"",
				""content"": [
				  {
					""type"": ""text"",
					""text"": ""I am Prakhar""
				  }
				]
			  }
			]
		  },
		  ""customfield_29922"":{""id"":1, ""value"":""something"", ""self"":""https://localhost:8080""}
		  }
		}
		}`)
		var data map[string]interface{}
		if err := json.Unmarshal(byteResponse, &data); err != nil {
			t.Errorf(errUnmarshalByteResp)
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		issueDetails, err := jiraSvc.ExtractIssueResponse(ctx, data)
		assert.Nil(t, issueDetails)
		assert.NotNil(t, err)
		expectedError := ""json: cannot unmarshal number into Go struct field DropDownField.id of type string""
		assert.EqualError(t, err, expectedError)
	})
	t.Run(""getIssueParentKey fails"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
		}
		byteResponse := []byte(`{""issue"":{""id"":""54128"",""key"":""MNBS-99"",""self"":""https://localhost:9000/54128"",""fields"":{""customfield_29847"":""geneva0e45-880b-43b9-b211-8bd4ab209c2c"",""customfield_29848"":""PROD"",""customfield_29850"":""WESTEUROPE"",""customfield_29849"":""PROD1"",""customfield_29852"":""provision-pg-mop-1vm"", ""customfield_29851"":""sampleuserbharat"",""customfield_29854"":""sampledb-bharat"",""customfield_29853"":""sample-1-bharat"",""customfield_29855"":""sample-1-bharat"",""customfield_29856"":""PROD1"",""customfield_29857"":""WESTEUROPE"",""summary"":""Sample summary"",""description"":{
			""version"": 1,
			""type"": ""doc"",
			""content"": [
			  {
				""type"": ""paragraph"",
				""content"": [
				  {
					""type"": ""text"",
					""text"": ""I am Prakhar""
				  }
				]
			  }
			]
		  },
		  ""customfield_29922"":{""id"":""1"", ""value"":""something"", ""self"":""https://localhost:8080""},
		  ""parent"":{""id"":1, ""key"":""MNBS-009"", ""self"":""https://localhost:8080""}
		  }
		}
		}`)
		var data map[string]interface{}
		if err := json.Unmarshal(byteResponse, &data); err != nil {
			t.Errorf(errUnmarshalByteResp)
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		issueDetails, err := jiraSvc.ExtractIssueResponse(ctx, data)
		assert.Nil(t, issueDetails)
		assert.NotNil(t, err)
		expectedError := ""json: cannot unmarshal number into Go struct field InwardIssue.id of type string""
		assert.EqualError(t, err, expectedError)
	})
	t.Run(""getIssueType fails"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
		}
		byteResponse := []byte(`{""issue"":{""id"":""54128"",""key"":""MNBS-99"",""self"":""https://localhost:9000/54128"",""fields"":{""customfield_29847"":""geneva0e45-880b-43b9-b211-8bd4ab209c2c"",""customfield_29848"":""PROD"",""customfield_29850"":""WESTEUROPE"",""customfield_29849"":""PROD1"",""customfield_29852"":""provision-pg-mop-1vm"", ""customfield_29851"":""sampleuserbharat"",""customfield_29854"":""sampledb-bharat"",""customfield_29853"":""sample-1-bharat"",""customfield_29855"":""sample-1-bharat"",""customfield_29856"":""PROD1"",""customfield_29857"":""WESTEUROPE"",""summary"":""Sample summary"",""description"":{
			""version"": 1,
			""type"": ""doc"",
			""content"": [
			  {
				""type"": ""paragraph"",
				""content"": [
				  {
					""type"": ""text"",
					""text"": ""I am Prakhar""
				  }
				]
			  }
			]
		  },
		  ""customfield_29922"":{""id"":""1"", ""value"":""something"", ""self"":""https://localhost:8080""},
		  ""parent"":{""id"":""1"", ""key"":""MNBS-009"", ""self"":""https://localhost:8080""},
		  ""issuetype"":{""self"":""https://localhost:8080"", ""id"":1, ""description"":""I am at Maersk""}
		  }
		}
		}`)
		var data map[string]interface{}
		if err := json.Unmarshal(byteResponse, &data); err != nil {
			t.Errorf(errUnmarshalByteResp)
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		issueDetails, err := jiraSvc.ExtractIssueResponse(ctx, data)
		assert.Nil(t, issueDetails)
		assert.NotNil(t, err)
		expectedError := ""json: cannot unmarshal number into Go struct field IssueType.id of type string""
		assert.EqualError(t, err, expectedError)
	})
	t.Run(""getIssueType returns issueName"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
		}
		byteResponse := []byte(`{""issue"":{""id"":""54128"",""key"":""MNBS-99"",""self"":""https://localhost:9000/54128"",""fields"":{""customfield_29847"":""geneva0e45-880b-43b9-b211-8bd4ab209c2c"",""customfield_29848"":""PROD"",""customfield_29850"":""WESTEUROPE"",""customfield_29849"":""PROD1"",""customfield_29852"":""provision-pg-mop-1vm"", ""customfield_29851"":""sampleuserbharat"",""customfield_29854"":""sampledb-bharat"",""customfield_29853"":""sample-1-bharat"",""customfield_29855"":""sample-1-bharat"",""customfield_29856"":""PROD1"",""customfield_29857"":""WESTEUROPE"",""summary"":""Sample summary"",""description"":{
			""version"": 1,
			""type"": ""doc"",
			""content"": [
			  {
				""type"": ""paragraph"",
				""content"": [
				  {
					""type"": ""text"",
					""text"": ""I am Prakhar""
				  }
				]
			  }
			]
		  },
		  ""customfield_29922"":{""id"":""1"", ""value"":""something"", ""self"":""https://localhost:8080""},
		  ""parent"":{""id"":""1"", ""key"":""MNBS-009"", ""self"":""https://localhost:8080""},
		  ""issuetype"":{""self"":""https://localhost:8080"", ""id"":""54321"", ""description"":""I am at Maersk"",""name"":""Support""}
		  }
		}
		}`)
		var data map[string]interface{}
		if err := json.Unmarshal(byteResponse, &data); err != nil {
			t.Errorf(errUnmarshalByteResp)
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		issueDetails, err := jiraSvc.ExtractIssueResponse(ctx, data)
		assert.Nil(t, err)
		assert.NotNil(t, issueDetails)
		expectedIssue := entities.IssueDetails{ID: ""54128"",
			Key:              issueID99,
			Self:             selfURL,
			TenantID:         tenantID,
			HostingPlatform:  ""something"",
			EnvironmentClass: ""PROD"",
			HostRegion:       ""WESTEUROPE"",
			HostEnvironment:  ""PROD1"",
			SpecPlan:         specPlan,
			SpecUser:         ""sampleuserbharat"",
			SpecDatabase:     sampleDB,
			ApplicationName:  appID,
			ApplicationCode:  appID,
			ZoneEnvironment:  ""PROD1"",
			ZoneRegion:       ""WESTEUROPE"",
			ParentKey:        ""MNBS-009"",
			Description:      "" I am Prakhar"",
			Summary:          sampleSummary,
			ResourceID:       """",
			IssueType:        ""Support""}
		assert.Equal(t, &expectedIssue, issueDetails)
	})
}"
"func TransformResource(r provent.Resource) Resource {
	var (
		dbName, userName, appName, appCode string
	)
	if dbNameIf, ok := r.Payload[provent.DatabaseNameKey.String()]; ok {
		dbName = dbNameIf.(string)
	}
	if userNameIf, ok := r.Payload[provent.UserNameKey.String()]; ok {
		userName = userNameIf.(string)
	}
	if appNameIf, ok := r.Payload[provent.ApplicationNameKey.String()]; ok {
		appName = appNameIf.(string)
	}
	if appCodeIf, ok := r.Payload[provent.ApplicationCodeKey.String()]; ok {
		appCode = appCodeIf.(string)
	}
	return Resource{
		ID:               r.ID,
		TenantID:         r.TenantID,
		EnvironmentClass: r.EnvironmentClass,
		Source:           r.Source,
		JIRATicketID:     r.JIRATicketID,
		Metadata: Metadata{
			Orchestrator: r.Orchestrator,
			Hosting: Hosting{
				Environment: r.Environment,
				Region:      Region{Name: r.Region},
			},
		},
		Payload: Payload{
			Name:            r.Name,
			DBName:          dbName,
			UserName:        userName,
			ApplicationName: appName,
			ApplicationCode: appCode,
		},
		Outputs: r.Outputs,
		Status: Status{
			ID:      r.ID,
			Code:    r.State,
			Message: r.Message,
		},
	}
}","func TestTransformResource(t *testing.T) {
	res := TransformResource(provent.Resource{
		ID:           ""sample"",
		Orchestrator: ""orca"",
		Region:       ""eu-west"",
		Payload:      provmsi.Msi{provent.DatabaseNameKey.String(): ""postgres""},
	})
	assert.Equal(t, ""sample"", res.ID)
	assert.Equal(t, ""orca"", res.Metadata.Orchestrator)
	assert.Equal(t, ""eu-west"", res.Metadata.Hosting.Region.Name)
	res = TransformResource(provent.Resource{
		ID:      ""sample"",
		Region:  ""eu-west"",
		Payload: provmsi.Msi{provent.UserNameKey.String(): ""postgres""},
	})
	assert.Equal(t, ""sample"", res.ID)
	assert.Equal(t, 0, len(res.Metadata.Orchestrator))
	assert.Equal(t, ""eu-west"", res.Metadata.Hosting.Region.Name)
	res = TransformResource(provent.Resource{
		ID:           ""sample"",
		Orchestrator: ""orca"",
		Payload:      provmsi.Msi{provent.ApplicationNameKey.String(): ""omnibase""},
	})
	assert.Equal(t, ""sample"", res.ID)
	assert.Equal(t, 0, len(res.Metadata.Hosting.Region.Name))
	assert.Equal(t, ""orca"", res.Metadata.Orchestrator)
	res = TransformResource(provent.Resource{
		ID:      ""sample"",
		Payload: provmsi.Msi{provent.ApplicationCodeKey.String(): ""omnibase""},
	})
	assert.Equal(t, ""sample"", res.ID)
	assert.Equal(t, 0, len(res.Metadata.Hosting.Region.Name))
	assert.Equal(t, 0, len(res.Metadata.Orchestrator))
}"
"func (c controller) GetHealthV1(ctx context.Context, request oas.GetHealthV1RequestObject) (oas.GetHealthV1ResponseObject, error) {
	action := ""GetHealth""
	requestComplete := metrics.TrackActiveRequests(action)
	defer requestComplete()
	logger.L.InfoCtx(ctx, ""health check"")

	metrics.TrackHttpRequestsTransactions(""GET"", strconv.Itoa(http.StatusOK), action)

	if c.svc == nil {
		metrics.ApplicationUptime.WithLabelValues(cfg.APICfg.OpenTelemetry.ServiceName).Set(0.0)
		logger.L.ErrorCtx(ctx, ""controller svc not initialized"")
		return oas.GetHealthV1503JSONResponse{}, nil
	}
	if err := c.svc.Health(ctx); err != nil {
		metrics.ApplicationUptime.WithLabelValues(cfg.APICfg.OpenTelemetry.ServiceName).Set(0.0)
		logger.L.ErrorCtx(ctx, ""health check failed"", zap.Error(err))
		return oas.GetHealthV1503JSONResponse{}, nil
	}
	metrics.ApplicationUptime.WithLabelValues(cfg.APICfg.OpenTelemetry.ServiceName).Set(1.0)
	return oas.GetHealthV1200JSONResponse{}, nil
}","func TestGetHealthV1(t *testing.T) {
	up := oas.GetHealthV1200JSONResponse{}
	down := oas.GetHealthV1503JSONResponse{}
	ctx := context.Background()
	controller := NewFactory().Finalize()
	response, err := controller.GetHealthV1(ctx, oas.GetHealthV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, down, response)
	controller = NewFactory().WithProviaSvc(mocks.MockProviaSvc{
		HealthFn: func(ctx context.Context) error { return errors.New(""some error"") },
	}).Finalize()
	response, err = controller.GetHealthV1(ctx, oas.GetHealthV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, down, response)
	controller = NewFactory().WithProviaSvc(mocks.MockProviaSvc{
		HealthFn: func(ctx context.Context) error { return nil },
	}).Finalize()
	response, err = controller.GetHealthV1(ctx, oas.GetHealthV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, up, response)
}"
"func NewFeedbackService(r interfaces.ManagerRepository, p mqint.Publisher, t opentelemetry.OtelTracer, j jiraint.JiraService) interfaces.FeedbackHandler {
	return provisioningmanager.NewFeedbackHandler(r, p, t, j)
}","func TestNewFeedbackService(t *testing.T) {
	svc := NewFeedbackService(nil, nil, nil, nil)
	assert.NotNil(t, svc)
}"
"func (d *dispatcher) Provision(ctx context.Context, req provent.Resource) error {
	logger.L.InfoCtx(ctx, ""received req"", zap.String(""Provision"", req.Name), zap.Any(""req"", req))

	_, span := tracer.Start(ctx, ""ProvisionHandler"")
	defer span.End()

	plan, err := d.fetchPlan(ctx, req)
	if err != nil {
		return err
	}

	template, templateData, err := d.fetchTemplate(ctx, req, plan)
	if err != nil {
		return err
	}

	if err := d.processTemplate(ctx, template, templateData); err != nil {
		return err
	}

	return d.triggerProvisioning(ctx, template)
}","func TestProvision(t *testing.T) {
	d := &dispatcher{
		inputs:     make(ombentities.Msi),
		apiOutputs: make(ombentities.Msi),
		outputs:    make(ombentities.Msi),
		class:      ombentities.NONPROD,
		request: &provent.Resource{
			EnvironmentClass: ombentities.NONPROD,
			Payload: ombentities.Msi{
				provent.DatabaseNameKey.String(): ""some"",
				provent.UserNameKey.String():     ""some"",
			},
		},
		details: ombentities.Request{},
		jobID:   ""test-job-id"",
	}
	rgSvc = rgmock.MockService{}
	ctx := context.Background()
	req := provent.Resource{
		EnvironmentClass: ombentities.NONPROD,
		Name:             ""test"",
	}
	var mockstartFn = opentelemetry.MockTracer.Start

	originalStartFn := mockstartFn
	defer func() { mockstartFn = originalStartFn }()

	mockTracer := opentelemetry.MockTracer{}
	mockstartFn = mockStart

	mockStart = func(m opentelemetry.MockTracer, ctx context.Context, spanName string, opts ...trace.SpanStartOption) (context.Context, trace.Span) {
		return ctx, trace.SpanFromContext(ctx)
	}

	originalTracer := tracer
	defer func() { tracer = originalTracer }()

	tracer = mockTracer

	mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{""key"": ""value""}`))
	}))
	defer mockServer.Close()

	err2 := templatorservice.Initialize(config.ExternalService{
		URL:              mockServer.URL,
		TimeoutInSeconds: 10,
	})
	assert.NoError(t, err2)

	//plan := ombentities.Plan{}
	tdata := []byte(""test-template-data"")
	mockPublisher := publishermock.MockPublisher{}
	InitializePublishSvc(mockPublisher)
	mockTFInput := ombentities.InputTemplate{
		Rg: ombentities.Rg{
			Name:     ""test-rg"",
			Location: ""test-location"",
		},
		Network: ombentities.Network{
			InternalLB: map[string]ombentities.IntLB{
				""lb_rule"": {
					FrontendPort: ""8080"",
				},
			},
		},
		VMs: ombentities.VM{},
	}
	var generateTFInputFn = d.generateTFInput
	var addJobFn = addJob
	var saveTemplateFn = saveTemplate
	var saveInitialStateFn = saveInitialState

	originalGenetareTFInputFn := generateTFInputFn
	generateTFInputFn = func(ctx context.Context, tpl ombentities.Template) (ombentities.InputTemplate, error) {
		return mockTFInput, nil
	}
	defer func() { generateTFInputFn = originalGenetareTFInputFn }()

	originalAddJobFn := addJobFn
	addJobFn = func(ctx context.Context, resourceID, rgName string) (entities.Job, error) {
		return entities.Job{
			ResourceID:        ""resource-123"",
			ResourceGroupName: ""rg-00000001"",
		}, nil
	}
	defer func() { addJobFn = originalAddJobFn }()

	originalSaveTemplateFn := saveTemplateFn
	saveTemplateFn = func(ctx context.Context, template entities.Template) error {
		return nil
	}
	defer func() { saveTemplateFn = originalSaveTemplateFn }()

	originalSaveInitialStateFn := saveInitialStateFn
	saveInitialStateFn = func(ctx context.Context, state entities.InfraState) error {
		return nil
	}
	defer func() { saveInitialStateFn = originalSaveInitialStateFn }()

	tpl := ombentities.Template{
		Plan: ombentities.Plan{EnvironmentClass: ombentities.PROD},
		Details: ombentities.Request{
			TenantID:     ""tenantID"",
			Environment:  ""env"",
			Location:     ""location"",
			DatabaseName: ""some"",
			UserName:     ""some"",
		},
		Steps: map[uint][]ombentities.Step{
			1: {
				{
					Task: ombentities.Task{
						Name:    ""provision"",
						Payload: map[string]interface{}{""key"": ""value""},
					},
				},
			},
		},
	}

	repo = mocks.MockRepository{
		FetchMappingsFn: func(ctx context.Context, mapping entities.ResourceGroupMapping) ([]entities.ResourceGroupMapping, error) {
			return []entities.ResourceGroupMapping{{ResourceGroupName: ""testrg"", TenantID: ""tenantID"", Environment: ""dev""}}, nil
		},
	}

	var startWorkflowFn = d.startWorkflow
	originalStartWorkflowFn := startWorkflowFn
	startWorkflowFn = func(ctx context.Context, tpl ombentities.Template) error {
		return nil
	}

	defer func() { startWorkflowFn = originalStartWorkflowFn }()

	mockSecretStore := secstr.NewMockSecretStore(
		secstr.WithGetSecret(func(ctx context.Context, key string) (string, error) {
			switch key {
			case ""clientIDKey"":
				return ""mockClientID"", nil
			case ""clientSecretKey"":
				return ""mockClientSecret"", nil
			case ""tenantIDKey"":
				return ""mockTenantID"", nil
			case ""subscriptionIDKey"":
				return ""mockSubscriptionID"", nil
			default:
				return """", nil
			}
		}),
	)

	mockMssStore := secstr.NewMockSecretStore(
		secstr.WithSetSecret((func(ctx context.Context, key, value string) error {
			return nil
		}),
		))

	secretStore = mockSecretStore
	mssStore = mockMssStore

	generatePassword(5)
	err5 := setupTFEnv(ctx, ombentities.NONPROD)
	assert.NoError(t, err5)

	params := []string{}
	updatedParams, _ := d.generateAndStorePassword(context.Background(), ""some"", params)
	assert.NotNil(t, updatedParams)

	err4 := d.triggerProvisioning(ctx, tpl)
	assert.Nil(t, err4)

	err3 := d.processTemplate(ctx, tpl, tdata)
	assert.Nil(t, err3)

	err := d.Provision(ctx, req)

	assert.Error(t, err)
}"
"func (c controller) GetApplicationResourceV1(ctx context.Context, request oas.GetApplicationResourceV1RequestObject) (oas.GetApplicationResourceV1ResponseObject, error) {
	action := ""GetApplicationResourceV1""
	requestComplete := metrics.TrackActiveRequests(action)
	defer requestComplete()
	if c.svc == nil {
		metrics.TrackHttpRequestsTransactions(""GET"", strconv.Itoa(http.StatusNotFound), action)
		metrics.NumErrorRequests.Inc()
		logger.L.ErrorCtx(ctx, ""can't get resource"", zap.Error(errors.New(""controller has no svc"")))
		return oas.GetApplicationResourceV1404ApplicationProblemPlusJSONResponse{
			NotFoundApplicationProblemPlusJSONResponse: oas.NotFoundApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusNotFound,
				Detail:   ""Can't process due to bad data."",
				Instance: ""GET /applications/{applicationCode}/resources/v1/{resourceId}"",
			},
		}, nil
	}
	detail := """"
	if request.Params.Detail != nil {
		detail = *request.Params.Detail
	}
	res, err := c.svc.GetResource(ctx, request.ApplicationCode, request.ResourceId, detail)
	if err != nil {
		metrics.TrackHttpRequestsTransactions(""GET"", strconv.Itoa(http.StatusNotFound), action)
		logger.L.ErrorCtx(ctx, ""can't create resource"", zap.Error(err))
		return oas.GetApplicationResourceV1404ApplicationProblemPlusJSONResponse{
			NotFoundApplicationProblemPlusJSONResponse: oas.NotFoundApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusNotFound,
				Detail:   ""Can't process due to bad data."",
				Instance: ""GET /applications/{applicationCode}/resources/v1/{resourceId}"",
			},
		}, nil
	}
	metrics.TrackHttpRequestsTransactions(""GET"", strconv.Itoa(http.StatusOK), action)
	return oas.GetApplicationResourceV1200JSONResponse(views.TransformOASPGResource(res)), nil
}","func TestGetApplicationResourceV1(t *testing.T) {
	ctx := context.Background()
	someErr := errors.New(""some error"")
	errResponse := oas.GetApplicationResourceV1404ApplicationProblemPlusJSONResponse{
		NotFoundApplicationProblemPlusJSONResponse: oas.NotFoundApplicationProblemPlusJSONResponse{
			Title:    ""Service failed"",
			Status:   http.StatusNotFound,
			Detail:   ""Can't process due to bad data."",
			Instance: ""GET /applications/{applicationCode}/resources/v1/{resourceId}"",
		}}
	successResponse := oas.GetApplicationResourceV1200JSONResponse(views.TransformOASPGResource(provent.Resource{ID: ""two"", TenantID: ""one""}))
	controller := NewFactory().Finalize()
	assert.NotNil(t, controller)
	response, err := controller.GetApplicationResourceV1(ctx, oas.GetApplicationResourceV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
	controller = NewFactory().WithProviaSvc(nil).Finalize()
	response, err = controller.GetApplicationResourceV1(ctx, oas.GetApplicationResourceV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
	controller = NewFactory().WithProviaSvc(mocks.MockProviaSvc{
		GetResourceFn: func(ctx context.Context, tenantID, resourceID, detail string) (provent.Resource, error) {
			return provent.Resource{}, someErr
		},
	}).Finalize()
	response, err = controller.GetApplicationResourceV1(ctx, oas.GetApplicationResourceV1RequestObject{
		ApplicationCode: ""one"", ResourceId: ""two"",
	})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
	controller = NewFactory().WithProviaSvc(mocks.MockProviaSvc{
		GetResourceFn: func(ctx context.Context, tenantID, resourceID, detail string) (provent.Resource, error) {
			return provent.Resource{TenantID: ""one"", ID: ""two""}, nil
		},
	}).Finalize()
	response, err = controller.GetApplicationResourceV1(ctx, oas.GetApplicationResourceV1RequestObject{
		ApplicationCode: ""one"", ResourceId: ""two""})
	assert.Nil(t, err)
	assert.Equal(t, successResponse, response)
}"
"func (svc proviaSvc) AddResource(ctx context.Context, provRequest provent.Resource, body ombentities.Msi) (provent.Resource, error) {
	ctx, span := svc.tracer.Start(ctx, ""AddResource"")
	defer span.End()
	if svc.repository == nil {
		return provent.Resource{}, fmt.Errorf(errProviaRepo, ErrServiceNotInitialized)
	}
	if !provRequest.IsValid() {
		logger.L.ErrorCtx(ctx, errInvalidReq, zap.Any(""request"", provRequest))
		return provent.Resource{}, errors.New(errInvalidReq)
	}
	if err := provRequest.GenerateID(); err != nil {
		logger.L.ErrorCtx(ctx, ""couldnt generate id"", zap.Error(err), zap.Any(""request"", provRequest))
		return provent.Resource{}, errors.New(errInvalidReq)
	}
	provRequest.CreationInput = provRequest.Payload
	provRequest.State = uint(provent.PendingState)
	return svc.repository.CreateResource(ctx, provRequest)
}","func TestAddResource(t *testing.T) {
	ctx := context.TODO()

	t.Run(""repository not initialized"", func(t *testing.T) {
		svc := NewServiceFactory().WithTracer(testTracer).Finalize()
		assert.NotNil(t, svc)

		_, err := svc.AddResource(ctx, provent.Resource{}, map[string]interface{}{})
		assert.NotNil(t, err)
		assert.Contains(t, err.Error(), ""provia svc not initialized: provia repository"")
	})

	t.Run(""unsuccessful addition/missing dbname"", func(t *testing.T) {
		svc := NewServiceFactory().WithTracer(testTracer).WithRepository(mocks.MockRepository{
			CreateResourceFn: func(ctx context.Context, resource provent.Resource) (provent.Resource, error) {
				return resource, nil
			},
		}).Finalize()
		assert.NotNil(t, svc)

		resource := provent.Resource{
			TenantID:         ""sample"",
			EnvironmentClass: ombentities.NONPROD,
			Environment:      ""test"",
			Payload:          ombentities.Msi{provent.ApplicationNameKey.String(): ""app""},
		}
		body := map[string]interface{}{
			""key"": ""value"",
		}
		addedResource, err := svc.AddResource(ctx, resource, body)
		assert.NotNil(t, err)
		assert.Empty(t, addedResource.ID)
	})

	t.Run(""successful addition"", func(t *testing.T) {
		svc := NewServiceFactory().WithTracer(testTracer).WithRepository(mocks.MockRepository{
			CreateResourceFn: func(ctx context.Context, resource provent.Resource) (provent.Resource, error) {
				return resource, nil
			},
		}).Finalize()
		assert.NotNil(t, svc)

		resource := provent.Resource{
			TenantID:         ""sample"",
			EnvironmentClass: ombentities.NONPROD,
			Environment:      ""test"",
			Payload: ombentities.Msi{
				provent.ApplicationNameKey.String(): ""app"",
				provent.DatabaseNameKey.String():    ""sampledb"",
				provent.UserNameKey.String():        ""sampleuser"",
			},
		}
		body := map[string]interface{}{
			""key"": ""value"",
		}
		addedResource, err := svc.AddResource(ctx, resource, body)
		assert.Nil(t, err)
		assert.NotEmpty(t, addedResource.ID)
	})
}"
"func Open(name string) (*os.File, error) {
	return os.Open(name)
}","func TestOpen(t *testing.T) {
	t.Run(""Open Success"", func(t *testing.T) {
		tmpFile, err := os.CreateTemp("""", ""testfile"")
		if err != nil {
			t.Fatalf(""Failed to create temporary file: %v"", err)
		}
		defer os.Remove(tmpFile.Name())

		file, err := Open(tmpFile.Name())
		if err != nil {
			t.Errorf(""Open failed: %v"", err)
		}

		if file == nil {
			t.Errorf(""Expected a non-nil file, got nil"")
		}
		file.Close()
	})
	t.Run(""FileNotFound"", func(t *testing.T) {
		_, err := Open(""non_existent_file.txt"")

		if err == nil {
			t.Errorf(""Open should have failed for a non-existent file, but it didn't"")
		}
		if !os.IsNotExist(err) {
			t.Errorf(""Expected 'file not found' error, got %v"", err)
		}
	})
	t.Run(""PermissionDenied"", func(t *testing.T) {
		tmpFile, err := os.CreateTemp("""", ""testfile"")
		if err != nil {
			t.Fatalf(""Failed to create temporary file: %v"", err)
		}
		defer os.Remove(tmpFile.Name())

		err = tmpFile.Chmod(0400) // Read-only for owner
		if err != nil {
			t.Fatalf(""Failed to change file permissions: %v"", err)
		}

		// Try to open the file with write access
		_, err = os.OpenFile(tmpFile.Name(), os.O_RDWR, 0644)

		// Check if the expected error is returned
		if err == nil {
			t.Errorf(""Open should have failed due to permission denied, but it didn't"")
		}

		// You can also check for a specific error type if needed
		if !os.IsPermission(err) {
			t.Errorf(""Expected 'permission denied' error, got %v"", err)
		}

	})

}"
"func (m MockJiraSvc) CreateIssue(ctx context.Context, issue *entities.Issue) (*entities.ResponseIssue, error) {
	if m.CreateIssueFn != nil {
		return m.CreateIssueFn(ctx, issue)
	}
	return nil, nil
}","func TestCreateIssue(t *testing.T) {
	t.Run(""when issue is nil"", func(t *testing.T) {
		ss := mock.NewMockSecretStore(mock.WithGetSecret(func(ctx context.Context, key string) (string, error) { return ""bghssdyuun"", nil }))
		jiraSvc, _ := New(ctx, ss, JiraConf, nil)
		issueResp, err := jiraSvc.CreateIssue(ctx, nil)
		assert.Nil(t, issueResp)
		assert.NotNil(t, err)
		expectedErr := ""issue field is missing""
		assert.EqualError(t, err, expectedErr)
	})

	t.Run(""when httSvc client is nil"", func(t *testing.T) {
		jiraSvc1 := jiraSvc{}
		issue := entities.Issue{Fields: &entities.IssueFields{
			Attachment: []*entities.Attachment{
				{Filename: ""/Users/prakhar.sharma/go/src/github.com/Maersk-Global/omnibase-common/pkg/appinit/jira/examples/issue/myfile.txt""},
				{Filename: ""/Users/prakhar.sharma/go/src/github.com/Maersk-Global/omnibase-common/pkg/appinit/jira/examples/issue/India_GSC_Holiday_Calendar_2024.pdf""},
			},
			Issuetype:      &entities.IssueType{Name: ""Support""},
			RawDescription: issueDesc,
		}}
		issueResp, err := jiraSvc1.CreateIssue(ctx, &issue)
		assert.Nil(t, issueResp)
		assert.NotNil(t, err)
		expectedErr := errClientNotInitialized
		assert.EqualError(t, err, expectedErr)

	})
	t.Run(""GenerateURL fails"", func(t *testing.T) {
		ss := mock.NewMockSecretStore(mock.WithGetSecret(func(ctx context.Context, key string) (string, error) { return ""bghssdyuun"", nil }))
		jiraSvc, _ := New(ctx, ss, JiraConf, &utilStruct)
		issue := entities.Issue{Fields: &entities.IssueFields{
			Attachment: []*entities.Attachment{
				{Filename: issuefilePath},
				{Filename: holidayFilePath},
			},
			Issuetype:      &entities.IssueType{Name: ""Support""},
			RawDescription: issueDesc,
		}}
		issueResp, err := jiraSvc.CreateIssue(ctx, &issue)
		assert.Nil(t, issueResp)
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(""NewRequest fails"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return nil, errors.New(errMessage)
		}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		issue := entities.Issue{Fields: &entities.IssueFields{
			Attachment: []*entities.Attachment{
				{Filename: issuefilePath},
				{Filename: holidayFilePath},
			},
			Issuetype:      &entities.IssueType{Name: ""Support""},
			RawDescription: issueDesc,
		}}
		// utilStruct.GenerateUrl = getFinalUrlFn
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		issueResp, err := jiraSvc.CreateIssue(ctx, &issue)
		assert.Nil(t, issueResp)
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)

	})
	t.Run(""httpService.client.Do fails"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{}, []byte(`{""field1"": ""value1"", ""field2"": 42}`), errors.New(errMessage)
			}}
		issue := entities.Issue{Fields: &entities.IssueFields{
			Attachment: []*entities.Attachment{
				{Filename: issuefilePath},
				{Filename: holidayFilePath},
			},
			Issuetype:      &entities.IssueType{Name: ""Support""},
			RawDescription: issueDesc,
		}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		issueResp, err := jiraSvc.CreateIssue(ctx, &issue)
		assert.Nil(t, issueResp)
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)

	})
	t.Run(""when httpResponsecode != 201 and failed to unmarshal error"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{StatusCode: 500}, []byte(`{""field1"": ""value1"", `), nil
			}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		issue := entities.Issue{Fields: &entities.IssueFields{
			Attachment: []*entities.Attachment{
				{Filename: issuefilePath},
				{Filename: holidayFilePath},
			},
			Issuetype:      &entities.IssueType{Name: ""Support""},
			RawDescription: issueDesc,
		}}

		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		issueResp, err := jiraSvc.CreateIssue(ctx, &issue)
		assert.Nil(t, issueResp)
		assert.NotNil(t, err)
	})
	t.Run(""when httpResponsecode != 201 and marshal error"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{StatusCode: 500}, []byte(`{""field1"": ""value1"", ""field2"": 42}`), nil
			}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		issue := entities.Issue{Fields: &entities.IssueFields{
			Attachment: []*entities.Attachment{
				{Filename: issuefilePath},
				{Filename: holidayFilePath},
			},
			Issuetype:      &entities.IssueType{Name: ""Support""},
			RawDescription: issueDesc,
		}}

		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		issueResp, err := jiraSvc.CreateIssue(ctx, &issue)
		assert.Nil(t, issueResp)
		assert.NotNil(t, err)
	})
	t.Run(""Invalid Response JSON from client.Do"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{StatusCode: 201}, []byte(`{""field1"": ""value1"", `), nil
			}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		issue := entities.Issue{Fields: &entities.IssueFields{
			Attachment: []*entities.Attachment{
				{Filename: issuefilePath},
				{Filename: holidayFilePath},
			},
			Issuetype:      &entities.IssueType{Name: ""Support""},
			RawDescription: issueDesc,
		}}

		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		issueResp, err := jiraSvc.CreateIssue(ctx, &issue)
		assert.Nil(t, issueResp)
		assert.NotNil(t, err)
		expectedErr := ""unexpected end of JSON input""
		assert.EqualError(t, err, expectedErr)
	})

	t.Run(""when attachment List is not nil"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		newMultipartWriterFn = func(w io.Writer) (*multipart.Writer, error) {
			return multipart.NewWriter(w), nil
		}
		createFormFileFn = func(w *multipart.Writer, fieldname, filename string) (io.Writer, error) {
			return nil, nil
		}
		copyFn = func(dst io.Writer, src io.Reader) (int64, error) {
			return 0, nil
		}

		openFn = func(name string) (*os.File, error) {
			return &os.File{}, nil
		}
		issue := entities.Issue{Fields: &entities.IssueFields{
			Attachment: []*entities.Attachment{
				{Filename: ""/Users/Maersk/Global/myfile.txt""},
				{Filename: ""/Users/Maersk/Global/India_GSC_Holiday_Calendar_2024.pdf""},
			},
			Issuetype:      &entities.IssueType{Name: ""Support""},
			RawDescription: issueDesc,
		}}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		jiraSvc.newMultipartWriter = newMultipartWriterFn
		jiraSvc.createFormFile = createFormFileFn
		jiraSvc.copy = copyFn
		jiraSvc.open = openFn
		issueResp, err := jiraSvc.CreateIssue(ctx, &issue)
		assert.Nil(t, err)
		assert.NotNil(t, issueResp)
		responseIssue := new(entities.ResponseIssue)
		err = json.Unmarshal(body, &responseIssue)
		assert.NoError(t, err)
		assert.Equal(t, responseIssue, issueResp)
	})
	t.Run(""when attachment List is not nil but it fails to add attachment"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		openFn = func(name string) (*os.File, error) {
			return &os.File{}, errors.New(errMessage)
		}
		issue := entities.Issue{Fields: &entities.IssueFields{
			Attachment: []*entities.Attachment{
				{Filename: ""/Users/Maersk/Global/myfile.txt""},
				{Filename: ""/Users/Maersk/Global/India_GSC_Holiday_Calendar_2024.pdf""},
			},
			Issuetype:      &entities.IssueType{Name: ""Support""},
			RawDescription: issueDesc,
		}}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		jiraSvc.newMultipartWriter = newMultipartWriterFn
		jiraSvc.createFormFile = utils.CreateFormFile
		jiraSvc.copy = utils.Copy
		jiraSvc.open = openFn
		issueResp, err := jiraSvc.CreateIssue(ctx, &issue)
		assert.Nil(t, issueResp)
		assert.NotNil(t, err)
		expectedError := ""error opening file:some error""
		assert.EqualError(t, err, expectedError)
	})
	t.Run(""when attachment List is  nil"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		issue := entities.Issue{Fields: &entities.IssueFields{
			Issuetype:      &entities.IssueType{Name: ""Support""},
			RawDescription: issueDesc,
		}}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		issue.Fields.Attachment = nil
		issueResp, err := jiraSvc.CreateIssue(ctx, &issue)
		assert.Nil(t, err)
		assert.NotNil(t, issueResp)
		responseIssue := new(entities.ResponseIssue)
		err = json.Unmarshal(body, &responseIssue)
		assert.NoError(t, err)
		assert.Equal(t, responseIssue, issueResp)
	})

}"
"func Cleanup() error {
	var retErr error
	for _, fileName := range tempFiles {
		if err := os.Remove(fileName); err != nil {
			retErr = errors.Join(retErr, err)
		}
	}
	return retErr
}","func TestCleanup(t *testing.T) {
	ctx := context.Background()
	jobID := ""sample-job""

	// Case 1: No error, successful cleanup
	err := cleanup(ctx, jobID, nil)
	assert.Nil(t, err)

	// Case 2: Cleanup with an error cause
	cause := errors.New(""cleanup cause error"")
	err = cleanup(ctx, jobID, cause)
	assert.Nil(t, err)
}"
"func (r TestBlankRegionStore) GetRegionFSStore() *embed.FS {
	return nil
}","func TestGetRegionFSStore(t *testing.T) {
	store := (RegionStore{}).GetRegionFSStore()
	assert.NotNil(t, store)
}"
"func (svc proviaSvc) GetResource(ctx context.Context, tenantID, resourceID, detail string) (provent.Resource, error) {
	ctx, span := svc.tracer.Start(ctx, ""GetResource"")
	defer span.End()
	if svc.repository == nil {
		return provent.Resource{}, fmt.Errorf(errProviaRepo, ErrServiceNotInitialized)
	}
	resource, err := svc.repository.FetchResource(ctx, tenantID, resourceID)
	if err != nil {
		return provent.Resource{}, fmt.Errorf(""couldnt fetch resource: %w"", err)
	}
	if detail != includeIP {
		delete(resource.Outputs, ipKey)
	}
	return resource, nil
}","func TestGetResource(t *testing.T) {
	svc := NewServiceFactory().WithTracer(testTracer).Finalize()
	assert.NotNil(t, svc)

	ctx := context.TODO()

	_, err := svc.GetResource(ctx, ""nonexistingID"", ""nonexistingID"", """")
	assert.NotNil(t, err)
	svc = NewServiceFactory().WithTracer(testTracer).WithRepository(mocks.NewRepository()).Finalize()
	assert.NotNil(t, svc)
	_, err = svc.GetResource(ctx, ""nonexistingID"", ""nonexistingID"", """")
	assert.Nil(t, err)

	svc = NewServiceFactory().WithTracer(testTracer).WithRepository(mocks.MockRepository{
		FetchResourceFn: func(ctx context.Context, tenantID, resourceID string) (provent.Resource, error) {
			return provent.Resource{ID: ""resource1""}, nil
		},
	}).Finalize()
	resource, err := svc.GetResource(ctx, ""tenant1"", ""resource1"", """")
	assert.Equal(t, ""resource1"", resource.ID)
	assert.Nil(t, err)

	svc = NewServiceFactory().WithTracer(testTracer).WithRepository(mocks.MockRepository{
		FetchResourceFn: func(ctx context.Context, tenantID, resourceID string) (provent.Resource, error) {
			return provent.Resource{}, errors.New(""some fetch error"")
		},
	}).Finalize()
	resource, err = svc.GetResource(ctx, ""tenant1"", ""resource1"", """")
	assert.NotNil(t, err)
}"
"func InitializeMSS(s interfaces.SecretStore, scope string) {
	mss.Initialize(s, scope)
}","func TestInitializeMSS(t *testing.T) {
	var secretStoreMock interfaces.SecretStore
	scope := ""scope""
	InitializeMSS(secretStoreMock, scope)
}"
"func NewMockRepository() interfaces.ProviaRepository {
	return mocks.NewRepository()
}","func TestNewMockRepository(t *testing.T) {
	svc := NewMockRepository()
	assert.NotNil(t, svc)
}"
"func LoadUnitConfig(path string, newDecoder appinit.DecoderGen) error {
	fileData, err := appcfg.LoadConfigData(path)
	if err != nil {
		return err
	}
	if err := newDecoder(bytes.NewBuffer(fileData)).Decode(&UnitCfg); err != nil {
		return err
	}
	logger.L.Info(""config details"", zap.Any(""config"", UnitCfg))
	return nil
}","func TestLoadUnitConfig(t *testing.T) {
	vhostValue := ""example_vhost""
	consumerTag := ""example_consumerTag""
	t.Run(""Success"", func(t *testing.T) {
		config := Unit{
			DB: appcfg.Database{
				Host:         ""localhost"",
				Port:         5432,
				User:         ""user"",
				Password:     ""password"",
				DatabaseName: ""dbname"",
				SSLMode:      ""disable"",
			},
			ServerPort:  8080,
			MetricsPort: 9090,
			LogLevel:    ""info"",
			OpenTelemetry: appcfg.OpenTelemetry{
				ServiceName:      ""service"",
				Endpoint:         ""http://localhost:4317"",
				MetricsPort:      55680,
				TimeoutInSeconds: 30,
				Attributes: map[string]string{
					""key1"": ""value1"",
				},
			},
			MSS: appcfg.MSS{},
			MQ: appcfg.MessageQueue{
				Host:        """",
				Port:        0,
				Username:    """",
				Password:    """",
				Vhost:       &vhostValue,
				ConsumerTag: &consumerTag,
				Exchanges:   []appcfg.Exchange{},
				Queues:      []appcfg.Queue{},
			},
		}

		configData, err := yaml.Marshal(config)
		assert.NoError(t, err)

		tmpFile, err := os.CreateTemp("""", ""testconfig*.yaml"")
		assert.NoError(t, err)

		defer os.Remove(tmpFile.Name())

		_, err = tmpFile.Write([]byte(configData))
		assert.NoError(t, err)

		err = tmpFile.Close()
		assert.NoError(t, err)

		err = LoadUnitConfig(tmpFile.Name(), appinit.NewYAMLDecoder)
		assert.NoError(t, err)

		expectedConfig := &config
		// Handle nil and empty slice comparison
		if reflect.DeepEqual(expectedConfig.MSS.Scope, """") {
			expectedConfig.MSS.Scope = """"
		}
		if reflect.DeepEqual(expectedConfig.MSS.OmbApplication, """") {
			expectedConfig.MSS.OmbApplication = """"
		}
		assert.Equal(t, expectedConfig, UnitCfg, ""The configuration should be loaded correctly"")

	})

	t.Run(""File Not Found"", func(t *testing.T) {
		err := LoadUnitConfig(""nonexistent.yaml"", appinit.NewYAMLDecoder)
		assert.Error(t, err)
	})

	t.Run(""Invalid YAML"", func(t *testing.T) {
		configData := `
		db:
		  host: ""localhost""
		  port: 5432
		  user: ""user""
		  password: ""password""
		  database_name: ""dbname""
		  ssl_mode: ""disable""
		server_port: 8080
		metrics_port: 9090
		log_level: ""info""
		cors_origin: ""*""
		open_telemetry:
		  service_name: ""service""
		  endpoint: ""http://localhost:4317
		  metrics_port: 55680
		  timeout_in_seconds: 30
		  attributes:
		    key1: ""value1""`

		tmpFile, err := os.CreateTemp("""", ""testconfig*.yaml"")
		assert.NoError(t, err)

		defer os.Remove(tmpFile.Name())

		_, err = tmpFile.Write([]byte(configData))
		assert.NoError(t, err)

		err = tmpFile.Close()
		assert.NoError(t, err)

		err = LoadUnitConfig(tmpFile.Name(), appinit.NewYAMLDecoder)
		assert.Error(t, err)
	})
}"
"func (svc incidentSvc) PostIncident(payload []byte) (interface{}, error) {
	if svc.authToken == nil || svc.client == nil {
		return nil, errors.New(errIncidentSvcNotInit)
	}
	req, err := http.NewRequest(http.MethodPost, svc.incidentURL, bytes.NewBuffer(payload))
	logger.L.Info(""Incident POST URL: "", zap.Any(""URL"", req.URL.String()))
	if err != nil {
		logger.L.Error(errFormingReqObj, zap.Error(err))
		return nil, err
	}
	req = helper.JSONHeadersMiddleware(req, svc.authToken.AccessToken)

	return helper.HTTPClient(req, svc.client)
}","func TestPostIncident(t *testing.T) {
	mockAuthSvc := &mocks.MockAuthSvc{
		Token: &entities.AuthToken{AccessToken: ""testToken""},
	}

	mockServer := mockServer(http.StatusOK, []byte(`{""result"": ""success""}`))
	defer mockServer.Close()

	service := NewIncidentService(mockAuthSvc, mockServer.URL+""/incident"", &http.Client{})

	payload := []byte(`{""key"":""value""}`)
	result, err := service.PostIncident(payload)

	assert.NoError(t, err)
	assert.NotNil(t, result) 
}"
"func (m MockHttpClient) NewMultiPartRequest(ctx context.Context, method string, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
	if m.NewMultiPartRequestFn != nil {
		return m.NewMultiPartRequestFn(ctx, method, urlStr, body, reqHeaders)
	}
	return nil, nil
}","func TestNewMultiPartRequest(t *testing.T) {
	t.Run(""NewMultiPartRequestFn == nil"", func(t *testing.T) {
		mockClient := MockHttpClient{NewMultiPartRequestFn: nil}
		req, err := mockClient.NewMultiPartRequest(ctx, ""Post"", ""https://localhost:8080"", nil, nil)
		assert.Nil(t, req)
		assert.Nil(t, err)
	})
	t.Run(""NewMultiPartRequestFn != nil"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			}}

		req, err := mockHttpClient.NewMultiPartRequest(ctx, ""Post"", ""https://localhost:8080"", nil, nil)
		assert.NotNil(t, req)
		assert.Nil(t, err)
	})
}"
"func ExtractMsi(ctx context.Context, input string) (ombentities.Msi, error) {
	// outputBytes := stdout.String()
	first, last := strings.Index(input, ""{""), strings.LastIndex(input, ""}"")
	outputStr, err := strconv.Unquote(""`"" + string(input[first:last+1]) + ""`"")
	if err != nil {
		return nil, fmt.Errorf(""failed to read  input : %w"", err)
	}
	outputStr = strings.ReplaceAll(outputStr, ""\\"", """")
	var outputs ombentities.Msi
	if err := json.Unmarshal([]byte(outputStr), &outputs); err != nil {
		logger.L.WarnCtx(ctx, ""couldnt read  input string"", zap.Error(err))
	}
	return outputs, nil

}","func TestExtractMsi(t *testing.T) {
	tests := []struct {
		name      string
		input     string
		expectErr bool
		expected  ombentities.Msi
	}{
		{
			name:      ""Valid MSI JSON Input"",
			input:     `output={""key1"":""value1"",""key2"":123,""key3"":{""subkey"":""subvalue""}}`,
			expectErr: false,
			expected: ombentities.Msi{
				""key1"": ""value1"",
				""key2"": float64(123),
				""key3"": map[string]interface{}{""subkey"": ""subvalue""},
			},
		},
		{
			name:      ""Invalid JSON Input With Curly Braces"",
			input:     ""{\""key\"":value}"",
			expectErr: false,
		},
	}
	ctx := context.Background()
	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			result, err := ExtractMsi(ctx, tc.input)

			if tc.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tc.expected, result)
			}
		})
	}
}"
"func (svc publishSvc) PublishFeedback(ctx context.Context, req provent.Resource) error {
	return svc.publish(ctx, messagequeue.RequestsDirect, messagequeue.TaskFeedbackKey, """", req)
}","func TestPublishFeedback(t *testing.T) {
	t.Run(""publish feedback success"", func(t *testing.T) {
		mockPublisher := publishermock.MockPublisher{
			PublishFeedbackFn: func(ctx context.Context, req provent.Resource) error {
				return nil
			},
		}
		InitializePublishSvc(mockPublisher)
		req := provent.Resource{ID: ""resource-123""}
		mockPublisher.PublishFeedbackFn = func(ctx context.Context, req provent.Resource) error {
			return nil
		}
		ctx := context.TODO()

		err := publishFeedback(ctx, req, """")

		assert.NoError(t, err)
	})

	t.Run(""publish error"", func(t *testing.T) {
		mockPublisher := publishermock.MockPublisher{
			PublishFeedbackFn: func(ctx context.Context, req provent.Resource) error {
				return someError()
			},
		}
		InitializePublishSvc(mockPublisher)
		req := provent.Resource{}
		expectedErr := errors.New(""publish error"")
		mockPublisher.PublishFeedbackFn = func(ctx context.Context, req provent.Resource) error {
			return expectedErr
		}
		ctx := context.TODO()

		err := publishFeedback(ctx, req, """")

		assert.NoError(t, err)
	})
}"
"func (m MockJiraSvc) GetIssueDetails(ctx context.Context, issueKeyOrID string) (*entities.IssueDetails, error) {
	if m.GetIssueDetailsFn != nil {
		return m.GetIssueDetailsFn(ctx, issueKeyOrID)
	}
	return nil, nil
}","func TestGetIssueDetails(t *testing.T) {
	t.Run(""issueKeyorID is missing"", func(t *testing.T) {
		ss := mock.NewMockSecretStore(mock.WithGetSecret(func(ctx context.Context, key string) (string, error) { return ""bghssdyuun"", nil }))
		jiraSvc, _ := New(ctx, ss, JiraConf, nil)
		issueDetails, err := jiraSvc.GetIssueDetails(ctx, """")
		assert.Nil(t, issueDetails)
		assert.NotNil(t, err)
		expectedErr := ""either issue id or key is missing""
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(""svc.client == nil"", func(t *testing.T) {
		jiraSvc := jiraSvc{client: nil}
		issueDetails, err := jiraSvc.GetIssueDetails(ctx, issueID121)
		assert.Nil(t, issueDetails)
		assert.NotNil(t, err)
		expectedErr := errClientNotInitialized
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(""generateURL fails"", func(t *testing.T) {
		ss := mock.NewMockSecretStore(mock.WithGetSecret(func(ctx context.Context, key string) (string, error) { return ""bghssdyuun"", nil }))
		jiraSvc, _ := New(ctx, ss, JiraConf, &utilStruct)
		issueDetails, err := jiraSvc.GetIssueDetails(ctx, issueID121)
		assert.Nil(t, issueDetails)
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(clientReqFailureMsg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return nil, errors.New(errMessage)
		}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		issueDetails, err := jiraSvc.GetIssueDetails(ctx, issueID121)
		assert.Nil(t, issueDetails)
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(clientDoFailureMsg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{}, []byte(`{""field1"": ""value1"", ""field2"": 42}`), errors.New(errMessage)
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		issueDetails, err := jiraSvc.GetIssueDetails(ctx, issueID121)
		assert.Nil(t, issueDetails)
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(""when resp.StatusCode = http.StatusOK but fails while unmarshalling "", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{StatusCode: 200}, []byte(`{""field1"": ""value1"",`), nil
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		issueDetails, err := jiraSvc.GetIssueDetails(ctx, issueID121)
		assert.Nil(t, issueDetails)
		assert.NotNil(t, err)
		expectedErr := ""failed to unmarshal the issue response :unexpected end of JSON input""
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(""when resp.StatusCode = http.StatusOK but fails at ExtractIssueResponse"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{StatusCode: 200}, []byte(`{""issue"": {""fields"":{""description"":{""version"": 1,""type"": ""doc"",""content"": []}}}}`), nil
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		issueDetails, err := jiraSvc.GetIssueDetails(ctx, issueID121)
		assert.Nil(t, issueDetails)
		assert.NotNil(t, err)
		expectedErr := ""adf content list is missing""
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(""all pass scenario"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{StatusCode: 200}, []byte(`{""issue"":{""id"":""54128"",""key"":""MNBS-99"",""self"":""https://localhost:9000/54128"",""fields"":{""customfield_29847"":""geneva0e45-880b-43b9-b211-8bd4ab209c2c"",""customfield_29848"":""PROD"",""customfield_29850"":""WESTEUROPE"",""customfield_29849"":""PROD1"",""customfield_29852"":""provision-pg-mop-1vm"", ""customfield_29851"":""sampleuserbharat"",""customfield_29854"":""sampledb-bharat"",""customfield_29853"":""sample-1-bharat"",""customfield_29855"":""sample-1-bharat"",""customfield_29856"":""PROD1"",""customfield_29857"":""WESTEUROPE"",""summary"":""Sample summary"",""description"":{
    ""version"": 1,
    ""type"": ""doc"",
    ""content"": [
      {
        ""type"": ""paragraph"",
        ""content"": [
          {
            ""type"": ""text"",
            ""text"": ""I am Prakhar""
          }
        ]
      }
    ]
  }}
}
}`), nil
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		issueDetails, err := jiraSvc.GetIssueDetails(ctx, issueID99)
		assert.Nil(t, err)
		assert.NotNil(t, issueDetails)
		expectedIssue := entities.IssueDetails{ID: ""54128"",
			Key:              issueID99,
			Self:             ""https://localhost:9000/54128"",
			TenantID:         ""geneva0e45-880b-43b9-b211-8bd4ab209c2c"",
			HostingPlatform:  """",
			EnvironmentClass: ""PROD"",
			HostRegion:       ""WESTEUROPE"",
			HostEnvironment:  ""PROD1"",
			SpecPlan:         ""provision-pg-mop-1vm"",
			SpecUser:         ""sampleuserbharat"",
			SpecDatabase:     ""sampledb-bharat"",
			ApplicationName:  ""sample-1-bharat"",
			ApplicationCode:  ""sample-1-bharat"",
			ZoneEnvironment:  ""PROD1"",
			ZoneRegion:       ""WESTEUROPE"",
			ParentKey:        """",
			Description:      "" I am Prakhar"",
			Summary:          ""Sample summary"",
			ResourceID:       """",
			IssueType:        """"}
		assert.Equal(t, &expectedIssue, issueDetails)
	})

}"
"func FetchCurrentToken() (string, string) {
	return admTokenProd, admTokenNonProd
}","func TestFetchCurrentToken(t *testing.T) {
	vaultTokenP, vaultTokenNp = FetchCurrentToken()
	assert.NotNil(t, vaultTokenP)
	assert.NotNil(t, vaultTokenNp)
}"
"func Middleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		traceID := r.Header.Get(string(TraceID))
		if _, err := uuid.Parse(traceID); err != nil {
			traceID = uuid.Must(uuid.NewV7()).String()
		}
		ctx = context.WithValue(ctx, TraceID, traceID)
		w.Header().Set(string(TraceID), traceID)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}","func TestMiddleware(t *testing.T) {
	key, ok := mockSet.LookupKeyID(kid)
	if !ok {
		t.Fatalf(""key with kid %s not found"", kid)
	}

	token, err := jwt.NewBuilder().
		Issuer(""issuer"").
		Audience([]string{""audience""}).
		Expiration(time.Now().Add(time.Hour)).
		IssuedAt(time.Now()).
		JwtID(""jwtid"").
		Subject(""subject"").
		Build()
	assert.NoError(t, err)

	signedToken, err := jwt.Sign(token, jwt.WithKey(jwa.HS256, key))
	assert.NoError(t, err)

	//req := httptest.NewRequest(""GET"", ""/"", nil)
	req, _ := http.NewRequest(""GET"", ""/"", nil)

	t.Run(""Success"", func(t *testing.T) {
		req.Header.Set(""Authorization"", ""Bearer ""+string(signedToken))

		rr := httptest.NewRecorder()

		next := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusOK)
		})

		handler := auth.Middleware(next)
		handler.ServeHTTP(rr, req)

		assert.Equal(t, http.StatusOK, rr.Code)
	})

	t.Run(""VeryfyClaims"", func(t *testing.T) {
		req.Header.Set(""Authorization"", ""Bearer ""+string(signedToken))
		rr := httptest.NewRecorder()

		next := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusOK)
		})

		auth.claims[""aud""] = []string{""newAudience""}

		handler := auth.Middleware(next)
		handler.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusUnauthorized, rr.Code)
	})

	t.Run(""InvalidToken"", func(t *testing.T) {
		auth := jwtAuthenticator{}

		req.Header.Set(""Authorization"", ""Bearer invalidToken"")
		rr := httptest.NewRecorder()

		// Create a mock handler to wrap with the middleware
		next := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusOK)
		})

		handler := auth.Middleware(next)
		handler.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusUnauthorized, rr.Code)
	})

	t.Run(""EmptyToken"", func(t *testing.T) {
		auth := jwtAuthenticator{}

		req.Header.Set(""Authorization"", ""Bearer "")
		rr := httptest.NewRecorder()

		next := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusOK)
		})

		handler := auth.Middleware(next)
		handler.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusUnauthorized, rr.Code)
	})
}"
"func (svc proviaSvc) DeleteResource(ctx context.Context, tenantID, resourceID string) error {
	ctx, span := svc.tracer.Start(ctx, ""DeleteResource"")
	defer span.End()
	if svc.repository == nil {
		return fmt.Errorf(errProviaRepo, ErrServiceNotInitialized)
	}
	resource, err := svc.GetResource(ctx, tenantID, resourceID, """")
	if err != nil {
		return fmt.Errorf(""couldnt delete resource: %w"", err)
	}
	if !resource.CanBeDeleted() {
		return errors.New(""resource cant be deleted, current state is "" + provent.State(resource.State).String())
	}
	prevState := resource.State
	resource.State = uint(provent.PendingDeleteState)
	resource.Message = provent.PendingDeleteState.String()
	return svc.repository.UpdateResource(ctx, resource, prevState)
}","func TestDeleteResource(t *testing.T) {
	ctx := context.TODO()

	t.Run(""repository not initialized"", func(t *testing.T) {
		svc := NewServiceFactory().WithTracer(testTracer).Finalize()
		assert.NotNil(t, svc)

		err := svc.DeleteResource(ctx, ""tenant1"", ""resource1"")
		assert.NotNil(t, err)
		assert.Contains(t, err.Error(), ""provia svc not initialized: provia repository"")
	})

	t.Run(""resource not found"", func(t *testing.T) {
		svc := NewServiceFactory().WithTracer(testTracer).WithRepository(mocks.MockRepository{
			FetchResourceFn: func(ctx context.Context, tenantID, resourceID string) (provent.Resource, error) {
				return provent.Resource{}, errors.New(""resource not found"")
			},
		}).Finalize()
		assert.NotNil(t, svc)

		err := svc.DeleteResource(ctx, ""tenant1"", ""resource1"")
		assert.NotNil(t, err)
		assert.Contains(t, err.Error(), ""couldnt delete resource"")
	})

	t.Run(""resource cannot be deleted"", func(t *testing.T) {
		svc := NewServiceFactory().WithTracer(testTracer).WithRepository(mocks.MockRepository{
			FetchResourceFn: func(ctx context.Context, tenantID, resourceID string) (provent.Resource, error) {
				return provent.Resource{
					State: uint(provent.PendingDeleteState),
				}, nil
			},
		}).Finalize()
		assert.NotNil(t, svc)

		err := svc.DeleteResource(ctx, ""tenant1"", ""resource1"")
		assert.NotNil(t, err)
		assert.Contains(t, err.Error(), ""resource cant be deleted"")
	})

	t.Run(""successful deletion"", func(t *testing.T) {
		svc := NewServiceFactory().WithTracer(testTracer).WithRepository(mocks.MockRepository{
			FetchResourceFn: func(ctx context.Context, tenantID, resourceID string) (provent.Resource, error) {
				return provent.Resource{
					State: uint(0),
				}, nil
			},
			UpdateResourceFn: func(ctx context.Context, resource provent.Resource, state uint) error {
				return nil
			},
		}).Finalize()
		assert.NotNil(t, svc)

		err := svc.DeleteResource(ctx, ""tenant1"", ""resource1"")
		assert.Nil(t, err)
	})
}"
"func RegisterHealthChecks(r chi.Router, hc http.HandlerFunc) {
	r.Get(""/"", hc)
	r.HandleFunc(""/health"", hc)

	r.HandleFunc(""/ready"", func(writer http.ResponseWriter, request *http.Request) {
		WriteResponse(writer, StandardResponse{
			StatusCode: http.StatusOK,
		})
	})
}","func TestRegisterHealthChecks(t *testing.T) {
	r := chi.NewRouter()
	mockHealthHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if _, err := w.Write([]byte(""Health OK"")); 
		err != nil {        
		   http.Error(w, ""Failed to write response"", http.StatusInternalServerError) 
	       return   
		}
		w.WriteHeader(http.StatusOK)
	})

	RegisterHealthChecks(r, mockHealthHandler)

	t.Run(""Root Endpoint"", func(t *testing.T) {
		req, _ := http.NewRequest(http.MethodGet, ""/"", nil)
		rr := httptest.NewRecorder()
		r.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusOK, rr.Code)
		assert.Equal(t, ""Health OK"", rr.Body.String())
	})

	t.Run(""Health Endpoint"", func(t *testing.T) {
		req, _ := http.NewRequest(http.MethodGet, ""/health"", nil)
		rr := httptest.NewRecorder()
		r.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusOK, rr.Code)
		assert.Equal(t, ""Health OK"", rr.Body.String())
	})

	t.Run(""Ready Endpoint"", func(t *testing.T) {
		req, _ := http.NewRequest(http.MethodGet, ""/ready"", nil)
		rr := httptest.NewRecorder()
		r.ServeHTTP(rr, req)
		assert.Equal(t, http.StatusOK, rr.Code)
		assert.Equal(t, ""null"", rr.Body.String())
	})
}"
"func (svc proviaSvc) GetResources(ctx context.Context, tenantID string, size, page uint32) ([]provent.Resource, uint64, uint64, error) {
	ctx, span := svc.tracer.Start(ctx, ""GetResources"")
	defer span.End()
	if svc.repository == nil {
		return nil, 0, 0, fmt.Errorf(errProviaRepo, ErrServiceNotInitialized)
	}
	if size == 0 {
		size = defaultLimit
	}
	offset := uint32(0)
	if page > 1 {
		offset = size * (page - 1)
	}
	resources, err := svc.repository.FetchResources(ctx, tenantID, size, offset)
	if err != nil {
		return nil, 0, 0, fmt.Errorf(""couldnt fetch resources: %w"", err)
	}
	for i := range resources {
		delete(resources[i].Outputs, ipKey)
	}
	count, err := svc.repository.CountResources(ctx, tenantID)
	if err != nil {
		logger.L.ErrorCtx(ctx, ""couldnt count resources"", zap.Error(err))
	}
	return resources, count, uint64(math.Ceil(float64(count) / float64(size))), nil
}","func TestGetResources(t *testing.T) {
	svc := NewServiceFactory().WithTracer(testTracer).Finalize()
	assert.NotNil(t, svc)

	ctx := context.TODO()

	_, _, _, err := svc.GetResources(ctx, ""nonexistingID"", 0, 0)
	assert.NotNil(t, err)
	svc = NewServiceFactory().WithTracer(testTracer).WithRepository(mocks.NewRepository()).Finalize()
	assert.NotNil(t, svc)
	_, _, _, err = svc.GetResources(ctx, ""nonexistingID"", 0, 0)
	assert.Nil(t, err)

	svc = NewServiceFactory().WithTracer(testTracer).WithRepository(mocks.MockRepository{
		FetchResourcesFn: func(ctx context.Context, tenantID string, limit, offset uint32) ([]provent.Resource, error) {
			return []provent.Resource{{ID: ""resource1""}}, nil
		},
	}).Finalize()
	resources, _, _, err := svc.GetResources(ctx, ""tenant1"", 0, 0)
	assert.Equal(t, 1, len(resources))
	assert.Equal(t, ""resource1"", resources[0].ID)
	assert.Nil(t, err)

	svc = NewServiceFactory().WithTracer(testTracer).WithRepository(mocks.MockRepository{
		FetchResourcesFn: func(ctx context.Context, tenantID string, limit, offset uint32) ([]provent.Resource, error) {
			return []provent.Resource{}, nil
		},
	}).Finalize()
	resources, _, _, err = svc.GetResources(ctx, ""tenant1"", 0, 0)
	assert.Equal(t, 0, len(resources))
	assert.Nil(t, err)

	svc = NewServiceFactory().WithTracer(testTracer).WithRepository(mocks.MockRepository{
		FetchResourcesFn: func(ctx context.Context, tenantID string, limit, offset uint32) ([]provent.Resource, error) {
			return nil, errors.New(""some fetch error"")
		},
	}).Finalize()
	resources, _, _, err = svc.GetResources(ctx, ""tenant1"", 0, 0)
	assert.Equal(t, 0, len(resources))
	assert.NotNil(t, err)
}"
"func HTTPClient(req *http.Request, client *http.Client) (map[string]interface{}, error) {
	response, err := client.Do(req)
	if err != nil {
		logger.L.ErrorCtx(req.Context(), ""Error while hitting the API endpoint"", zap.Any(""Error: "", err))
		return nil, err
	}

	return httpResponseToString(response, err)

}","func TestHTTPClient(t *testing.T) {
	t.Run(""Success"", func(t *testing.T) {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set(""Content-Type"", ""application/json"")
			response := map[string]string{""message"": ""success""}
			json.NewEncoder(w).Encode(response)
		}))
		defer server.Close()

		client := &http.Client{}
		req, _ := http.NewRequestWithContext(context.Background(), ""GET"", server.URL, nil)

		resp, err := HTTPClient(req, client)
		assert.NoError(t, err)
		assert.Equal(t, ""success"", resp[""message""])
	})

	t.Run(""RequestError"", func(t *testing.T) {
		testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set(""Connection"", ""close"")
		}))
		defer testServer.Close()
	
		client := &http.Client{}
	
		req, err := http.NewRequest(""GET"", testServer.URL, nil)
		if err != nil {
			t.Fatalf(""Failed to create request: %v"", err)
		}
	
		testServer.Close()
	
		resp, err := HTTPClient(req, client)
	
		assert.Nil(t, resp, ""Expected response to be nil"")
		assert.Error(t, err, ""Expected an error to occur"")
	})

	t.Run(""Error Response"", func(t *testing.T) {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			http.Error(w, ""Internal Server Error"", http.StatusInternalServerError)
		}))
		defer server.Close()
	
		client := &http.Client{}
		req, _ := http.NewRequestWithContext(context.Background(), ""GET"", server.URL, nil)
	
		resp, err := HTTPClient(req, client)
		assert.Nil(t, resp)
		assert.Error(t, err)
	})
}"
"func GenerateDefaultReadyFunc(intf any) ReadyFunc {
	return func() bool {
		return DefaultIsReady(nil)
	}
}","func TestGenerateDefaultReadyFunc(t *testing.T) {
	originalDefaultIsReady := DefaultIsReady
	defer func() {
		DefaultIsReady = originalDefaultIsReady
	}()

	t.Run(""DefaultIsReady returns true"", func(t *testing.T) {
		DefaultIsReady = func(interfaces ...ReadyCheck) bool { return true }
		result := GenerateDefaultReadyFunc(nil)
		assert.True(t, result())
	})

	t.Run(""DefaultIsReady returns false"", func(t *testing.T) {
		DefaultIsReady = func(interfaces ...ReadyCheck) bool { return false }
		result := GenerateDefaultReadyFunc(nil)
		assert.False(t, result())
	})
}"
"func TransformOASPGResource(resource provent.Resource) oas.ApplicationResourceV1 {
	spec := oas.PostgresResourceSpecV1{
		Database: extractStr(resource.Payload[provent.DatabaseNameKey.String()]),
		Plan:     resource.Name,
		User:     extractStr(resource.Payload[provent.UserNameKey.String()]),
		Zone: oas.ZoneV1{
			Environment: &resource.Environment,
			Region:      &resource.Region,
		},
		Outputs:      (*map[string]interface{})(&resource.Outputs),
		JiraTicketId: &resource.JIRATicketID,
		Source:       &resource.Source,
	}
	retspec := oas.ApplicationResourceSpecV1{}
	if err := retspec.FromPostgresResourceSpecV1(spec); err != nil {
		logger.L.Warn(""couldnt transform resource spec"", zap.Error(err))
	}
	return oas.ApplicationResourceV1{
		EnvironmentClass: oas.EnvironmentClassV1(resource.EnvironmentClass),
		Id:               &resource.ID,
		Spec:             retspec,
		Status: &oas.ResourceStatusV1{
			CreatedDate:      resource.CreatedAt,
			LastModifiedDate: resource.UpdatedAt,
			StateCode:        mapResourceState(provent.State(resource.State)),
			StateMessage:     resource.Message,
		},
	}
}","func TestTransformOASPGResource(t *testing.T) {
	timeNow := time.Now()
	resource := provent.Resource{
		ID:               ""resource-1"",
		Environment:      ""prod"",
		Name:             ""example_plan"",
		Region:           ""us-west-1"",
		EnvironmentClass: ""production"",
		State:            3,
		Message:          ""Resource created successfully"",
		Payload: provmsi.Msi{
			provent.DatabaseNameKey.String(): ""example_db"",
			""name"":                           ""example_plan"",
			provent.UserNameKey.String():     ""example_user"",
		},
		Outputs: provmsi.Msi{
			""output_key"": ""output_value"",
		},
		CreatedAt: timeNow,
	}
	str := """"
	spec := oas.PostgresResourceSpecV1{
		Database: extractStr(resource.Payload[provent.DatabaseNameKey.String()]),
		Plan:     extractStr(resource.Payload[""name""]),
		User:     extractStr(resource.Payload[provent.UserNameKey.String()]),
		Zone: oas.ZoneV1{
			Environment: &resource.Environment,
			Region:      &resource.Region,
		},
		Outputs:      (*map[string]interface{})(&resource.Outputs),
		JiraTicketId: &str,
		Source:       &str,
	}
	retspec := oas.ApplicationResourceSpecV1{}
	if err := retspec.FromPostgresResourceSpecV1(spec); err != nil {
		logger.L.Warn(""couldnt transform resource spec"", zap.Error(err))
	}

	expected := oas.ApplicationResourceV1{
		EnvironmentClass: oas.EnvironmentClassV1(resource.EnvironmentClass),
		Id:               &resource.ID,
		Spec:             retspec,
		Status: &oas.ResourceStatusV1{
			CreatedDate:      resource.CreatedAt,
			LastModifiedDate: resource.UpdatedAt,
			StateCode:        oas.COMPLETED,
			StateMessage:     ""Resource created successfully"",
		},
	}

	actual := TransformOASPGResource(resource)

	assert.True(t, reflect.DeepEqual(actual, expected))
	assert.Equal(t, expected.EnvironmentClass, actual.EnvironmentClass)
	assert.Equal(t, expected.Id, actual.Id)
	assert.Equal(t, expected.Spec.ResourceType, actual.Spec.ResourceType)
	assert.Equal(t, expected.Status.CreatedDate, actual.Status.CreatedDate)
	assert.Equal(t, expected.Status.LastModifiedDate, actual.Status.LastModifiedDate)
	assert.Equal(t, expected.Status.StateCode, actual.Status.StateCode)
	assert.Equal(t, expected.Status.StateMessage, actual.Status.StateMessage)
}"
"func InitializeClientOptions() *azsecrets.ClientOptions {
	httpClient := initializeHttpClient()
	return &azsecrets.ClientOptions{
		ClientOptions: policy.ClientOptions{
			Transport: &httpClient,
		},
		DisableChallengeResourceVerification: true,
	}
}","func TestInitializeClientOptions(t *testing.T) {
	httpClient := initializeHttpClient()
	clientOptions := &azsecrets.ClientOptions{
		ClientOptions: policy.ClientOptions{
			Transport: &httpClient,
		},
		DisableChallengeResourceVerification: true,
	}
	assert.NotNil(t, clientOptions)
	InitializeClientOptions()
}"
"func NewMultipartWriter(w io.Writer) (*multipart.Writer, error) {
	return multipart.NewWriter(w), nil
}","func TestNewMultipartWriter(t *testing.T) {
	t.Run(allWellScenario, func(t *testing.T) {
		var buf bytes.Buffer
		writer, err := NewMultipartWriter(&buf)
		assert.Nil(t, err)
		assert.NotNil(t, writer)
	})
}"
"func (m MockJiraSvc) MarkIssueInProgress(ctx context.Context, issueIdorKey string, comment string) error {
	if m.MarkIssueInProgressFn != nil {
		return m.MarkIssueInProgressFn(ctx, issueIdorKey, comment)
	}
	return nil
}","func TestMarkIssueInProgress(t *testing.T) {
	t.Run(idOrKeyMissingMsg, func(t *testing.T) {
		ss := mock.NewMockSecretStore(mock.WithGetSecret(func(ctx context.Context, key string) (string, error) { return ""bghssdyuun"", nil }))
		jiraSvc, _ := New(ctx, ss, JiraConf, nil)
		err := jiraSvc.MarkIssueInProgress(ctx, """", ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errIssueIdOrKeyMissing
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(clientMissing, func(t *testing.T) {
		jiraSvc := jiraSvc{client: nil}
		err := jiraSvc.MarkIssueInProgress(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errClientNotInitialized
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(commentAddFailureMsg, func(t *testing.T) {
		ss := mock.NewMockSecretStore(mock.WithGetSecret(func(ctx context.Context, key string) (string, error) { return ""bghssdyuun"", nil }))
		jiraSvc, _ := New(ctx, ss, JiraConf, &utilStruct)
		err := jiraSvc.MarkIssueInProgress(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(clientReqFailureMsg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return nil, errors.New(errMessage)
		}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		err := jiraSvc.MarkIssueInProgress(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(clientDoFailureMsg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{}, []byte(`{""field1"": ""value1"", ""field2"": 42}`), errors.New(errMessage)
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		err := jiraSvc.MarkIssueInProgress(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(status204Msg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{StatusCode: 204}, []byte(`{""field1"": ""value1"", ""field2"": 42}`), nil
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		err := jiraSvc.MarkIssueInProgress(ctx, issueID121, ""Maersk"")
		assert.Nil(t, err)
	})
	t.Run(statusnot204Msg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{StatusCode: 502}, []byte(`{""field1"": ""value1"", ""field2"": 42}`), errors.New(errMessage)
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		err := jiraSvc.MarkIssueInProgress(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
}"
"func (c controller) GetEnvironmentsV1(ctx context.Context, request oas.GetEnvironmentsV1RequestObject) (oas.GetEnvironmentsV1ResponseObject, error) {
	env := ""PROD""
	return oas.GetEnvironmentsV1200JSONResponse([]oas.EnvironmentV1{
		{Name: &env},
	}), nil
}","func TestGetEnvironmentsV1(t *testing.T) {
	ctx := context.Background()
	controller := NewFactory().Finalize()

	expectedResponse := oas.GetEnvironmentsV1200JSONResponse([]oas.EnvironmentV1{
		{Name: new(string)},
	})
	*expectedResponse[0].Name = ""PROD""

	response, err := controller.GetEnvironmentsV1(ctx, oas.GetEnvironmentsV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, expectedResponse, response)
}"
"func StartProvisioningManager(mSvc interfaces.ManagerService, interval uint, done <-chan bool) error {
	if interval == 0 || interval > maxAllowedIntervalInSeconds {
		interval = defaultIntervalInSeconds
	}
	duration, err := time.ParseDuration(fmt.Sprintf(""%ds"", interval))
	if err != nil {
		return fmt.Errorf(""cannot determine the polling interval: %v"", err)
	}
	ticker := time.NewTicker(duration)
	ctx := context.Background()

	for {
		select {
		case <-done:
			return nil
		case <-ticker.C:
			if err := mSvc.Process(ctx); err != nil {
				logger.L.ErrorCtx(ctx, ""couldnt process requests"", zap.Error(err))
			}
			if err := mSvc.ProcessUpdate(ctx); err != nil {
				logger.L.ErrorCtx(ctx, ""couldnt process update requests"", zap.Error(err))
			}
			if err := mSvc.ProcessDecommissioning(ctx); err != nil {
				logger.L.ErrorCtx(ctx, ""couldnt process decommissioning requests"", zap.Error(err))
			}
		}
	}
}","func TestStartProvisioningManager(t *testing.T) {
	t.Run(""Successful execution"", func(t *testing.T) {
		done := make(chan bool)
		defer close(done)

		mockSvc := mocks.MockManagerService{
			MockSvcProcessor: mocks.MockSvcProcessor{
				ProcessFn:                func(ctx context.Context) error { return nil },
				ProcessUpdateFn:          func(ctx context.Context) error { return nil },
				ProcessDecommissioningFn: func(ctx context.Context) error { return nil },
			},
		}

		go func() {
			err := StartProvisioningManager(mockSvc, 2, done)
			assert.NoError(t, err)
		}()

		time.Sleep(3 * time.Second)
	})

	t.Run(""Invalid interval"", func(t *testing.T) {
		done := make(chan bool)
		defer close(done)

		mockSvc := mocks.MockManagerService{
			MockSvcProcessor: mocks.MockSvcProcessor{
				ProcessFn:                func(ctx context.Context) error { return nil },
				ProcessUpdateFn:          func(ctx context.Context) error { return nil },
				ProcessDecommissioningFn: func(ctx context.Context) error { return nil },
			},
		}

		go func() {
			err := StartProvisioningManager(mockSvc, 0, done) 
			assert.NoError(t, err)
		}()

		time.Sleep(6 * time.Second)
	})

	t.Run(""stops on done signal"", func(t *testing.T) {
		done := make(chan bool)

		mockSvc := mocks.MockManagerService{
			MockSvcProcessor: mocks.MockSvcProcessor{
				ProcessFn:                func(ctx context.Context) error { return nil },
				ProcessUpdateFn:          func(ctx context.Context) error { return nil },
				ProcessDecommissioningFn: func(ctx context.Context) error { return nil },
			},
		}

		go func() {
			err := StartProvisioningManager(mockSvc, 2, done)
			assert.NoError(t, err)
		}()

		time.Sleep(1 * time.Second)
		close(done)
		time.Sleep(1 * time.Second)
	})

	t.Run(""Handles error returned by methods"", func(t *testing.T) {
		done := make(chan bool)
		defer close(done)

		mockSvc := mocks.MockManagerService{
			MockSvcProcessor: mocks.MockSvcProcessor{
				ProcessFn: func(ctx context.Context) error {
					return errors.New(""mock error in Process"")
				},
				ProcessUpdateFn: func(ctx context.Context) error {
					return errors.New(""mock error in ProcessUpdate"")
				},
				ProcessDecommissioningFn: func(ctx context.Context) error {
					return errors.New(""mock error in ProcessDecommissioning"")
				},
			},
		}

		go func() {
			err := StartProvisioningManager(mockSvc, 2, done)
			assert.NoError(t, err)
		}()

		time.Sleep(3 * time.Second)
	})

	t.Run(""Handles invalid duration"", func(t *testing.T) {
		done := make(chan bool)
		defer close(done)

		mockSvc := mocks.MockManagerService{}

		invalidInterval := uint(5001) 

		go func() {
			err := StartProvisioningManager(mockSvc, invalidInterval, done)
			assert.NoError(t, err)
		}()

		time.Sleep(1 * time.Second)
	})
}"
"func (m *MockRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	if m.RoundTripFn != nil {
		return m.RoundTripFn(req), nil
	}
	return nil, errors.New(""no RoundTrip function provided"")
}","func TestRoundTrip(t *testing.T) {
	var mockHTTPRoundtripper = MockHttpRoundTripper{}
	tp := BasicAuthTransport{Username: emailAddress,
		Password:  defaultPassword,
		Transport: mockHTTPRoundtripper}
	req := &http.Request{
		Method: ""POST"",
		URL: &url.URL{
			Scheme:   ""https"",
			Host:     ""example.com"",
			Path:     ""/api/endpoint"",
			RawQuery: ""param1=value1&param2=value2"",
		},
		Header: http.Header{
			""Content-Type"":  []string{""application/json""},
			""Authorization"": []string{""Bearer your-token""},
		},
		Body: io.NopCloser(bytes.NewBufferString(`{""message"": ""Mocked Data""}`)),
	}
	resp, err := tp.RoundTrip(req)
	assert.Nil(t, err)
	assert.NotNil(t, resp)
	assert.Equal(t, &http.Response{
		StatusCode: 200,
		Body:       io.NopCloser(bytes.NewBufferString(`{""message"": ""Mocked Data""}`)),
	}, resp)
}"
"func NewFactory() *controllerOption {
	return &controllerOption{
		cntlr: controller{},
	}
}","func TestNewFactory(t *testing.T) {
	factory := NewFactory()
	assert.NotNil(t, factory)
	controller := factory.Finalize()
	assert.NotNil(t, controller)

	// add a livefn
	controller = NewFactory().WithLiveFn(func() bool { return true }).Finalize()
	assert.NotNil(t, controller)
	// add a readyfn
	controller = NewFactory().WithReadyFn(func() bool { return true }).Finalize()
	assert.NotNil(t, controller)
	// add provia svc
	controller = NewFactory().WithProviaSvc(mocks.MockProviaSvc{}).Finalize()
	assert.NotNil(t, controller)
	// add region svc
	controller = NewFactory().WithRegionSvc(regmock.MockRegionService{}).Finalize()
	assert.NotNil(t, controller)
	// add environment svc
	controller = NewFactory().WithEnvironmentSvc(envmock.MockEnvironmentService{}).Finalize()
	assert.NotNil(t, controller)
	// add all dependencies
	NewFactory().
		WithLiveFn(func() bool { return true }).
		WithReadyFn(func() bool { return true }).
		WithProviaSvc(mocks.MockProviaSvc{}).
		WithRegionSvc(regmock.MockRegionService{}).
		WithEnvironmentSvc(envmock.MockEnvironmentService{}).
		Finalize()
	assert.NotNil(t, controller)
}"
"func (m MockHttpClient) Do(req *http.Request) (*http.Response, []byte, error) {
	if m.DoFn != nil {
		return m.DoFn(req)
	}
	return nil, nil, nil
}","func TestDo(t *testing.T) {
	t.Run(""DoFn == nil"", func(t *testing.T) {
		mockClient := MockHttpClient{DoFn: nil}
		resp, body, err := mockClient.Do(&http.Request{})
		assert.Nil(t, resp)
		assert.Nil(t, err)
		assert.Nil(t, body)

	})
	t.Run(""DoFn != nil"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			}}
		resp, body, err := mockHttpClient.Do(&http.Request{})
		assert.NotNil(t, resp)
		assert.Nil(t, err)
		assert.NotNil(t, body)
	})

}"
"func (t *BasicAuthTransport) Client() *http.Client {
	return &http.Client{Transport: t}
}","func TestClient(t *testing.T) {
	var mockHTTPRoundtripper = MockHttpRoundTripper{}
	tp := BasicAuthTransport{Username: emailAddress,
		Password:  defaultPassword,
		Transport: mockHTTPRoundtripper}
	client := tp.Client()
	assert.NotNil(t, client)
}"
"func (p *PostgresOnVM) GetYAMLTagsAndValues() []string {
	var values []string
	t := reflect.ValueOf(p).Elem()
	for i := 0; i < t.NumField(); i++ {
		field := t.Type().Field(i)
		valueField := t.Field(i)
		tag := field.Tag.Get(tagName)
		values = append(values, fmt.Sprintf(""%s=%v"", tag, valueField.Interface()))
	}
	return values
}","func TestGetYAMLTagsAndValues(t *testing.T) {
	postgres := &PostgresOnVM{
		UUID:                   ""VJ-uuid"",
		ResourceGroupName:      ""resource-group-name"",
		VnetName:               ""vnet-name"",
		SubnetName:             ""subnet-name"",
		PostgresSG:             ""postgres-sg"",
		ImageName:              ""vm-image-name"",
		GalleryName:            ""gallery-name"",
		ImageResourceGroupName: ""image-resource-group-name"",
		InstanceType:           ""vm-instance-type"",
		DiskSizeInGB:           50,
		Admin:                  ""admin-user"",
		SubscriptionID:         ""sub-id"",
		ClientID:               ""client-id"",
		ClientSecret:           ""client-secret"",
		TenantID:               ""tenant-id"",
	}

	expected := []string{
		""uuid=VJ-uuid"",
		""resource_group_name=resource-group-name"",
		""vnet_name=vnet-name"",
		""subnet_name=subnet-name"",
		""postgres_sg=postgres-sg"",
		""vm_image_name=vm-image-name"",
		""gallery_name=gallery-name"",
		""image_resource_group_name=image-resource-group-name"",
		""vm_instance_type=vm-instance-type"",
		""disk_size_gb=50"",
		""vm_admin=admin-user"",
		""azure-subscription-id=sub-id"",
		""azure-client-id=client-id"",
		""azure-client-secret=client-secret"",
		""azure-tenant-id=tenant-id"",
	}

	result := postgres.GetYAMLTagsAndValues()
	assert.ElementsMatch(t, expected, result, ""GetYAMLTagsAndValues should return correct YAML tags and values"")
}"
"func (c controller) GetApplicationResourcesV1(ctx context.Context, request oas.GetApplicationResourcesV1RequestObject) (oas.GetApplicationResourcesV1ResponseObject, error) {
	action := ""GetApplicationResources""
	requestComplete := metrics.TrackActiveRequests(action)
	defer requestComplete()
	logger.L.InfoCtx(ctx, ""fetching resource"")
	if c.svc == nil {
		metrics.TrackHttpRequestsTransactions(""GET"", strconv.Itoa(http.StatusBadRequest), action)
		metrics.NumErrorRequests.Inc()
		logger.L.ErrorCtx(ctx, ""can't get application resources"", zap.Error(errors.New(""controller has no svc"")))
		return oas.GetApplicationResourcesV1404ApplicationProblemPlusJSONResponse{
			NotFoundApplicationProblemPlusJSONResponse: oas.NotFoundApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusBadRequest,
				Detail:   ""Can't process due to internal server error."",
				Instance: ""/applications/{applicationCode}/resources/v1"",
			}}, nil
	}
	pageNum := 1
	if request.Params.Page != nil && *request.Params.Page > 1 {
		pageNum = *request.Params.Page
	}
	size := 0
	if request.Params.Size != nil && *request.Params.Size > 0 {
		size = *request.Params.Size
	}
	resources, count, num, err := c.svc.GetResources(ctx, request.ApplicationCode, uint32(size), uint32(pageNum))
	if err != nil {
		metrics.TrackHttpRequestsTransactions(""GET"", strconv.Itoa(http.StatusBadRequest), action)
		logger.L.ErrorCtx(ctx, ""can't get tenant resources"", zap.Error(errors.New(""controller has no svc"")))
		return oas.GetApplicationResourcesV1404ApplicationProblemPlusJSONResponse{
			NotFoundApplicationProblemPlusJSONResponse: oas.NotFoundApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusBadRequest,
				Detail:   ""Can't process due to internal server error."",
				Instance: ""/applications/{applicationCode}/resources/v1"",
			},
		}, nil
	}
	metrics.TrackHttpRequestsTransactions(""GET"", strconv.Itoa(http.StatusOK), action)
	return oas.GetApplicationResourcesV1200JSONResponse{
		Content:       (views.TransformOASPGResources(resources)),
		TotalElements: int(count),
		TotalPages:    int(num),
		First:         pageNum == 1,
		Last:          pageNum == int(num),
		Size:          size,
		Number:        pageNum,
	}, nil
}","func TestGetApplicationResourcesV1(t *testing.T) {
	ctx := context.Background()
	someErr := errors.New(""some error"")
	errResponse := oas.GetApplicationResourcesV1404ApplicationProblemPlusJSONResponse{
		NotFoundApplicationProblemPlusJSONResponse: oas.NotFoundApplicationProblemPlusJSONResponse{
			Title:    ""Service failed"",
			Status:   http.StatusBadRequest,
			Detail:   ""Can't process due to internal server error."",
			Instance: ""/applications/{applicationCode}/resources/v1"",
		}}
	successResponse := oas.GetApplicationResourcesV1200JSONResponse{
		Content:       (views.TransformOASPGResources([]provent.Resource{{ID: ""two"", TenantID: ""one""}})),
		TotalElements: 1,
		TotalPages:    1,
		First:         true,
		Last:          true,
		Number:        1,
		Size:          0,
	}
	anotherSuccessResponse := oas.GetApplicationResourcesV1200JSONResponse{
		Content: (views.TransformOASPGResources([]provent.Resource{
			{ID: ""two"", TenantID: ""one""},
			{ID: ""three"", TenantID: ""one""},
		})),
		TotalElements: 1,
		TotalPages:    1,
		First:         true,
		Last:          true,
		Number:        1,
		Size:          0,
	}

	controller := NewFactory().Finalize()
	assert.NotNil(t, controller)
	response, err := controller.GetApplicationResourcesV1(ctx, oas.GetApplicationResourcesV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
	controller = NewFactory().WithProviaSvc(nil).Finalize()
	response, err = controller.GetApplicationResourcesV1(ctx, oas.GetApplicationResourcesV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
	controller = NewFactory().WithProviaSvc(mocks.MockProviaSvc{
		GetResourcesFn: func(ctx context.Context, tenantID string, limit, offset uint32) ([]provent.Resource, uint64, uint64, error) {
			return nil, 0, 0, someErr
		},
	}).Finalize()
	response, err = controller.GetApplicationResourcesV1(ctx, oas.GetApplicationResourcesV1RequestObject{ApplicationCode: ""one""})
	assert.Nil(t, err)
	assert.Equal(t, errResponse, response)
	controller = NewFactory().WithProviaSvc(mocks.MockProviaSvc{
		GetResourcesFn: func(ctx context.Context, tenantID string, limit, offset uint32) ([]provent.Resource, uint64, uint64, error) {
			return []provent.Resource{{ID: ""two"", TenantID: ""one""}}, 1, 1, nil
		},
	}).Finalize()
	response, err = controller.GetApplicationResourcesV1(ctx, oas.GetApplicationResourcesV1RequestObject{ApplicationCode: ""one""})
	assert.Nil(t, err)
	assert.Equal(t, successResponse, response)
	controller = NewFactory().WithProviaSvc(mocks.MockProviaSvc{
		GetResourcesFn: func(ctx context.Context, tenantID string, limit, offset uint32) ([]provent.Resource, uint64, uint64, error) {
			return []provent.Resource{{ID: ""two"", TenantID: ""one""}, {ID: ""three"", TenantID: ""one""}}, 1, 1, nil
		},
	}).Finalize()
	response, err = controller.GetApplicationResourcesV1(ctx, oas.GetApplicationResourcesV1RequestObject{ApplicationCode: ""one""})
	assert.Nil(t, err)
	assert.Equal(t, anotherSuccessResponse, response)
}"
"func (er envRepo) FetchEnvironments(ctx context.Context) (map[string]string, error) {
	if er.envMap == nil {
		return nil, errors.New(""can't fetch environments values. environment map is not initialised"")
	}
	var environments map[string]string = make(map[string]string, len(er.envMap))
	for env, description := range er.envMap {
		environments[env] = description
	}
	return environments, nil
}","func TestFetchEnvironments(t *testing.T) {
	var (
		err    error
		repo   interfaces.EnvironmentRepository
		envMap map[string]string
		error  string = ""can't fetch environments values. environment map is not initialised""
	)
	repo, _ = New()
	envMap, err = repo.FetchEnvironments(context.Background())
	assert.Nil(t, err)
	assert.NotNil(t, envMap)
	assert.Equal(t, len(envMap), 15)

	// Test when repo.envMap is nil
	repo = envRepo{envMap: nil}
	envMap, err = repo.FetchEnvironments(context.Background())
	assert.NotNil(t, err)
	assert.Nil(t, envMap)
	assert.Error(t, errors.New(error))
}"
"func Init(cfg config.Servicenow) {
	clientID = cfg.ClientID
	clientSecret = cfg.ClientSecret
	username = cfg.Username
	password = cfg.Password
}","func TestInit(t *testing.T) {
	testSpec := swag.GetSwagger(SwaggerInfo.InstanceName())

	assert.NotNil(t, testSpec, ""Expected SwaggerInfo to be registered"")
}"
"func GetTraceProviderFromResourceAndProcessor(res *resource.Resource, bsp sdktrace.SpanProcessor,
	exporter *otlptrace.Exporter) *sdktrace.TracerProvider {
	return sdktrace.NewTracerProvider(
		sdktrace.WithSampler(sdktrace.AlwaysSample()),
		sdktrace.WithResource(res),
		sdktrace.WithSpanProcessor(bsp),
		sdktrace.WithBatcher(exporter),
	)
}","func TestGetTraceProviderFromResourceAndProcessor(t *testing.T) {
	mockResource := &resource.Resource{}
	mockExporter := &otlptrace.Exporter{}
	mockSpanProcessor := sdktrace.NewSimpleSpanProcessor(mockExporter)

	t.Run(""Successful"", func(t *testing.T) {
		tracerProvider := GetTraceProviderFromResourceAndProcessor(mockResource, mockSpanProcessor, mockExporter)
		assert.NotNil(t, tracerProvider)
	})
}"
"func NewAzureKV(url, environment string) (interfaces.SecretStore, error) {
	return azurekv.New(url, nil, environment)
}","func TestNewAzureKV(t *testing.T) {
	url := ""url""
	environment := ""environment""
	secretStore, err := NewAzureKV(url, environment)
	assert.NotNil(t, secretStore)
	assert.NoError(t, err)
}"
"func (d dispatcher) HelmChartInstallPostgresHandler(ctx context.Context, req provent.Resource) error {
	logger.L.InfoCtx(ctx, ""received req"", zap.String(""helmInstaller"", req.Name), zap.Any(""req"", req))
	if err := hcaasInvoker(ctx, hcaasOptions{
		driver:    ""memory"",
		location:  ""postgresql-12.11.2.tgz"",
		release:   ""pg01"",
		namespace: ""pg-db01"",
	}); err != nil {
		return d.ErrorHandler(ctx)
	}
	req.State = uint(provent.CompletedState)
	return publisher.PublishFeedback(ctx, req)
}","func TestHelmChartInstallPostgresHandler(t *testing.T) {
	mockPublisher := mocks.MockPublisher{}
	InitializePublishSvc(mockPublisher)
	d := &dispatcher{}
	ctx := context.Background()

	t.Run(""success"", func(t *testing.T) {
		req := provent.Resource{
			Name: ""test-postgres"",
		}
		err := d.HelmChartInstallPostgresHandler(ctx, req)
		assert.NoError(t, err)
	})
}"
"func NewClient(httpClient httpClient) (*clientSvc, error) {
	return &clientSvc{
		client: httpClient,
	}, nil
}","func TestNewClient(t *testing.T) {
	var client httpClient = nil
	opClient, err := NewClient(client)
	assert.Nil(t, err)
	assert.NotNil(t, opClient)
	expectedClientSvc := &clientSvc{client: nil}
	assert.Equal(t, expectedClientSvc, opClient)
}"
"func (t *BasicAuthTransport) GetTransport() http.RoundTripper {
	if t.Transport != nil {
		return t.Transport
	}
	return http.DefaultTransport
}","func TestGetTransport(t *testing.T) {
	// Case 1 : When Transport is nil
	tp := BasicAuthTransport{Username: emailAddress,
		Password: defaultPassword,
	}
	transport := tp.GetTransport()
	assert.NotNil(t, transport)
	assert.Equal(t, http.DefaultTransport, transport)

	// Case 2: When mock transport is initialised
	var mockHTTPRoundtripper = MockHttpRoundTripper{}
	tp = BasicAuthTransport{Username: emailAddress,
		Password:  defaultPassword,
		Transport: mockHTTPRoundtripper}
	transport = tp.GetTransport()
	assert.NotNil(t, transport)
	assert.Equal(t, mockHTTPRoundtripper, transport)

}"
"func New(c *pgxpool.Pool, t opentelemetry.OtelTracer) interfaces.UnitRepository {
	dbTracer = t
	return unitRepository{conn: c}
}","func TestNew(t *testing.T) {
	t.Run(""Success"", func(t *testing.T) {
		clientIDProdKey := ""clientIDProdKey""
		clientSecretProdKey := ""clientSecretProdKey""
		clientIDNonProdKey := ""clientIDNonProdKey""
		clientSecretNonProdKey := ""clientSecretNonProdKey""
		getTokenFn := func() (string, string) {
			return ""Ptoken"", ""Nptoken""
		}
		secretStore, err := New(getTokenFn, clientIDProdKey, clientSecretProdKey, clientIDNonProdKey, clientSecretNonProdKey)
		assert.NoError(t, err)
		assert.NotNil(t, secretStore)
	})
}"
"func (c controller) UpdateApplicationResourceV1(ctx context.Context, request oas.UpdateApplicationResourceV1RequestObject) (oas.UpdateApplicationResourceV1ResponseObject, error) {
	action := ""UpdateApplicationResourceV1""
	requestComplete := metrics.TrackActiveRequests(action)
	defer requestComplete()

	metrics.TrackHttpRequestsTransactions(""PUT"", strconv.Itoa(http.StatusAccepted), action)
	if c.svc == nil {
		metrics.TrackHttpRequestsTransactions(""POST"", strconv.Itoa(http.StatusBadRequest), action)
		metrics.NumErrorRequests.Inc()
		logger.L.ErrorCtx(ctx, ""can't update resource"", zap.Error(errors.New(""controller has no svc"")))
		return oas.UpdateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
			BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusBadRequest,
				Detail:   ""Can't process due to internal server error."",
				Instance: ""PUT /applications/{applicationCode}/resources/v1/{resourceId}"",
			},
		}, nil
	}

	if request.Body == nil {
		metrics.TrackHttpRequestsTransactions(""POST"", strconv.Itoa(http.StatusBadRequest), action)
		return oas.UpdateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
			BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusBadRequest,
				Detail:   ""Can't process update due to bad/missing data."",
				Instance: ""PUT /applications/{applicationCode}/resources/v1/{resourceId}"",
			},
		}, nil
	}
	discriminator, err := request.Body.Spec.Discriminator()
	if err != nil {
		metrics.TrackHttpRequestsTransactions(""POST"", strconv.Itoa(http.StatusBadRequest), action)
		return oas.UpdateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
			BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusBadRequest,
				Detail:   ""Can't process update due to bad/missing data."",
				Instance: ""PUT /applications/{applicationCode}/resources/v1/{resourceId}"",
			},
		}, nil
	}
	var payload ombentities.Msi
	payload, err = extractUpdatePayload(ctx, discriminator, request)
	if err != nil {
		logger.L.ErrorCtx(ctx, ""invalid update request"", zap.Error(err), zap.Any(""spec"", request.Body.Spec))
		return oas.UpdateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
			BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusBadRequest,
				Detail:   updateResourceErrorDetail,
				Instance: ""PUT /applications/{applicationCode}/resources/v1/{resourceId}"",
			},
		}, nil
	}
	req, err := c.svc.UpdateResource(ctx, request.ApplicationCode, request.ResourceId, payload)
	if err != nil {
		metrics.TrackHttpRequestsTransactions(""PUT"", strconv.Itoa(http.StatusBadRequest), action)
		metrics.NumErrorRequests.Inc()
		logger.L.ErrorCtx(ctx, ""can't update resource"", zap.Error(err))
		return oas.UpdateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
			BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
				Title:    ""Service failed"",
				Status:   http.StatusBadRequest,
				Detail:   updateResourceErrorDetail,
				Instance: ""PUT /applications/{applicationCode}/resources/v1/{resourceId}"",
			},
		}, nil
	}
	metrics.TrackHttpRequestsTransactions(""PUT"", strconv.Itoa(http.StatusAccepted), action)
	return oas.UpdateApplicationResourceV1202JSONResponse(views.TransformOASPGResource(req)), nil
}","func TestUpdateApplicationResourceV1(t *testing.T) {
	ctx := context.Background()
	badRequestResponse := oas.UpdateApplicationResourceV1400ApplicationProblemPlusJSONResponse{
		BadRequestApplicationProblemPlusJSONResponse: oas.BadRequestApplicationProblemPlusJSONResponse{
			Title:    ""Service failed"",
			Status:   http.StatusBadRequest,
			Detail:   ""Can't process due to internal server error."",
			Instance: ""PUT /applications/{applicationCode}/resources/v1/{resourceId}"",
		},
	}

	controller := NewFactory().Finalize()
	assert.NotNil(t, controller)

	response, err := controller.UpdateApplicationResourceV1(ctx, oas.UpdateApplicationResourceV1RequestObject{})
	assert.Nil(t, err)
	assert.Equal(t, badRequestResponse, response)
}"
"func TokenFetcher(ctx context.Context) {
	if err := setToken(ctx); err != nil {
		logger.L.FatalCtx(ctx, ""iniital admiral token fetch failed"", zap.Error(err))
		return
	}
	ticker := time.NewTicker(defaultTokenRefreshIntervalInMinutes * time.Minute)
	for range ticker.C {
		logger.L.InfoCtx(ctx, ""refreshing admiral token"")
		if err := setToken(ctx); err != nil {
			logger.L.ErrorCtx(ctx, ""could set admiral token"", zap.Error(err))
		}
	}
}","func TestTokenFetcher(t *testing.T) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	setTokenFn = func(ctx context.Context) error {
		return nil
	}

	go TokenFetcher(ctx)

	time.Sleep(1 * time.Second)
}"
"func StartProvisioningUnit(b broker.Broker) {
	log.Println(""starting provisioning unit process ..."")
	broker.InitBroker(b)

	go func() {
		if err := broker.Start(); err != nil {
			log.Fatal(err)
		}
	}()
}","func TestStartProvisioningUnit(t *testing.T) {
	var logOutput bytes.Buffer
	log.SetOutput(&logOutput)

	t.Run(""Successful Broker Start"", func(t *testing.T) {
		logOutput.Reset()
		testBroker := &TestBroker{
			startError: nil,
		}
		StartProvisioningUnit(testBroker)

		if testBroker.Start()!=nil{
			log.Fatal(""failed to start provisioning unit"")
		}
	})
}"
"func ParseConfig(ctx context.Context, configFilePath string) (*Config, error) {
	var config Config
	data, err := os.ReadFile(configFilePath)
	if err != nil {
		logger.L.ErrorCtx(ctx, ""Error in reading file"", zap.Error(err))
		return nil, err
	}
	err = yaml.Unmarshal(data, &config)
	if err != nil {
		logger.L.ErrorCtx(ctx, ""Error in unmarshalling config object"", zap.Error(err))
		return nil, err
	}
	return &config, nil
}","func TestParseConfig(t *testing.T) {
	ctx := context.TODO()
	config, err := ParseConfig(ctx, """")
	assert.Nil(t, config)
	assert.Equal(t, ""open : no such file or directory"", err.Error())

	config, err = ParseConfig(ctx, ""./config_junk.yaml"")
	assert.Nil(t, config)
	assert.Equal(t, ""yaml: unmarshal errors:\n  line 1: cannot unmarshal !!str `cnelkcnlke` into config.Config"", err.Error())

	config, err = ParseConfig(ctx, ""./config_local.yaml"")
	assert.NotNil(t, config)
	assert.Nil(t, err)

	assert.Equal(t, ""localhost"", config.DB.Host)
	assert.Equal(t, uint16(8090), config.ServerPort)
	assert.Equal(t, uint(10), config.IntervalInSeconds)
	assert.Equal(t, ""debug"", config.LogLevel)
}"
"func CreateFormFile(w *multipart.Writer, fieldname, filename string) (io.Writer, error) {
	return w.CreateFormFile(fieldname, filename)
}","func TestCreateFormFile(t *testing.T) {
	t.Run(allWellScenario, func(t *testing.T) {
		var buf bytes.Buffer
		writer, err := NewMultipartWriter(&buf)
		assert.Nil(t, err)
		assert.NotNil(t, writer)
		cWrite, err := CreateFormFile(writer, ""Maersk"", ""/home/Maerks/Global/"")
		assert.Nil(t, err)
		assert.NotNil(t, cWrite)
	})
}"
"func (m MockJiraSvc) MarkIssueDone(ctx context.Context, issueIdorKey string, comment string) error {
	if m.MarkIssueDoneFn != nil {
		return m.MarkIssueDoneFn(ctx, issueIdorKey, comment)
	}
	return nil
}","func TestMarkIssueDone(t *testing.T) {
	t.Run(idOrKeyMissingMsg, func(t *testing.T) {
		ss := mock.NewMockSecretStore(mock.WithGetSecret(func(ctx context.Context, key string) (string, error) { return ""bghssdyuun"", nil }))
		jiraSvc, _ := New(ctx, ss, JiraConf, nil)
		err := jiraSvc.MarkIssueDone(ctx, """", ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errIssueIdOrKeyMissing
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(clientMissing, func(t *testing.T) {
		jiraSvc := jiraSvc{client: nil}
		err := jiraSvc.MarkIssueDone(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errClientNotInitialized
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(commentAddFailureMsg, func(t *testing.T) {
		ss := mock.NewMockSecretStore(mock.WithGetSecret(func(ctx context.Context, key string) (string, error) { return ""bghssdyuun"", nil }))
		jiraSvc, _ := New(ctx, ss, JiraConf, &utilStruct)
		err := jiraSvc.MarkIssueDone(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(clientReqFailureMsg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return nil, errors.New(errMessage)
		}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		err := jiraSvc.MarkIssueDone(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(clientDoFailureMsg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{}, []byte(`{""field1"": ""value1"", ""field2"": 42}`), errors.New(errMessage)
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		err := jiraSvc.MarkIssueDone(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
	t.Run(status204Msg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{StatusCode: 204}, []byte(`{""field1"": ""value1"", ""field2"": 42}`), nil
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		err := jiraSvc.MarkIssueDone(ctx, issueID121, ""Maersk"")
		assert.Nil(t, err)
	})
	t.Run(statusnot204Msg, func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
			return &http.Request{}, nil
		},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return &http.Response{StatusCode: 502}, []byte(`{""field1"": ""value1"", ""field2"": 42}`), errors.New(errMessage)
			},
		}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		err := jiraSvc.MarkIssueDone(ctx, issueID121, ""Maersk"")
		assert.NotNil(t, err)
		expectedErr := errMessage
		assert.EqualError(t, err, expectedErr)
	})
}"
"func TransformEnvironments(environments map[string]string) []Environment {
	var envList []Environment
	if environments == nil {
		return envList
	}
	for env := range environments {
		envList = append(envList, Environment{Name: strings.ToLower(env)})
	}
	return envList
}","func TestTransformEnvironments(t *testing.T) {
	var envMap map[string]string = map[string]string{""dev"": ""Development"", ""prod"": ""Production""}

	// Empty environment map
	envList := TransformEnvironments(nil)
	assert.Nil(t, envList)

	// Empty environment map
	envList2 := TransformEnvironments(envMap)
	assert.NotNil(t, envList2)
	assert.Equal(t, len([]Environment{{Name: ""dev""}, {Name: ""prod""}}), len(envList2))

}"
"func SetupLogger(configLogLevel string) {
	encoderConfig := ecszap.NewDefaultEncoderConfig()
	logLevel := parseLogLevel(configLogLevel)
	core := ecszap.NewCore(encoderConfig, os.Stdout, logLevel)
	logger := zap.New(core, zap.AddCaller())
	zap.ReplaceGlobals(logger)
	L.l = zap.L()
}","func TestSetupLogger(t *testing.T) {
	// default mode should be development mode
	SetupLogger(""debug"")
	if L.Level() != zap.DebugLevel {
		t.Error(""logger has not been setup correctly"")
	}
	// check the production mode
	SetupLogger("""")
	if L.Level() != zap.InfoLevel {
		t.Error(""logger has not been setup correctly in production mode"")
	}
}"
"func (db unitRepository) AddJob(ctx context.Context, job entities.Job) error {
	_, span := dbTracer.Start(ctx, ""DBAddJob"")
	defer span.End()
	if db.conn == nil {
		return errMissingDBConn
	}
	if _, err := db.conn.Exec(ctx, `
	INSERT INTO 
		jobs
		(
			id
			, resource_id
			, resource_group_name
			, status
			, created_at
			, updated_at
		)
		VALUES
		(
			$1
			, $2
			, $3
			, $4
			, NOW()
			, NOW()
		)
	ON CONFLICT
		DO NOTHING			
	`, job.ID, job.ResourceID, job.ResourceGroupName, job.Status); err != nil {
		return fmt.Errorf(""couldnt insert job: %v"", err)
	}
	return nil
}","func TestAddJob(t *testing.T) {

	repo = mocks.MockRepository{}
	ctx := context.Background()
	resourceID := ""resource123""
	resourceGroupName := ""rg-name""
	expectedJob := entities.Job{
		ResourceID:        resourceID,
		ResourceGroupName: resourceGroupName,
		Status:            entities.JobCreated,
	}

	repo.AddJob(ctx, expectedJob)

	repo = mocks.MockRepository{
		AddJobFn: func(ctx context.Context, job entities.Job) error {
			return nil
		},
	}

	job, err := addJob(ctx, resourceID, resourceGroupName)

	assert.NoError(t, err)
	assert.Equal(t, resourceID, job.ResourceID)
	assert.Equal(t, resourceGroupName, job.ResourceGroupName)
	assert.Equal(t, entities.JobCreated, job.Status)
}"
"func (m MockJiraSvc) AddIssueAttachments(ctx context.Context, attachments []*entities.Attachment, issueIdOrKey string) error {
	if m.AddIssueAttachmentsFn != nil {
		return m.AddIssueAttachmentsFn(ctx, attachments, issueIdOrKey)
	}
	return nil
}","func TestAddIssueAttachments(t *testing.T) {
	t.Run(""attachments are nil"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		err := jiraSvc.AddIssueAttachments(ctx, nil, ""MNBS-121"")
		expectedError := errAttachmentsOrKeyMissing
		assert.NotNil(t, err)
		assert.EqualError(t, err, expectedError)
	})
	t.Run(""issueIDOrKey is missing"", func(t *testing.T) {
		jiraSvc := jiraSvc{}
		attachments := []*entities.Attachment{
			{Filename: myfilePath},
			{Filename: holidayCalendarPath},
		}
		err := jiraSvc.AddIssueAttachments(ctx, attachments, """")
		expectedError := errAttachmentsOrKeyMissing
		assert.NotNil(t, err)
		assert.EqualError(t, err, expectedError)
	})
	t.Run(""all well scenario"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		newMultipartWriterFn = func(w io.Writer) (*multipart.Writer, error) {
			return multipart.NewWriter(w), nil
		}
		createFormFileFn = func(w *multipart.Writer, fieldname, filename string) (io.Writer, error) {
			return nil, nil
		}
		copyFn = func(dst io.Writer, src io.Reader) (int64, error) {
			return 0, nil
		}

		openFn = func(name string) (*os.File, error) {
			return &os.File{}, nil
		}

		attachments := []*entities.Attachment{
			{Filename: myfilePath},
			{Filename: holidayCalendarPath},
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		jiraSvc.newMultipartWriter = newMultipartWriterFn
		jiraSvc.createFormFile = createFormFileFn
		jiraSvc.copy = copyFn
		jiraSvc.open = openFn
		err := jiraSvc.AddIssueAttachments(ctx, attachments, issueID99)
		assert.Nil(t, err)
	})
	t.Run(""multiple filenames are missing"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			}}
		jiraSvc := jiraSvc{client: mockHttpClient}
		attachments := []*entities.Attachment{
			{Filename: """"},
			{Filename: """"},
		}
		err := jiraSvc.AddIssueAttachments(ctx, attachments, issueID99)
		assert.Nil(t, err)
	})
	t.Run(""uploadAttachment fails at open"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
		}
		openFn = func(name string) (*os.File, error) {
			return &os.File{}, errors.New(errMessage)
		}

		attachments := []*entities.Attachment{
			{Filename: myfilePath},
			{Filename: holidayCalendarPath},
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.open = openFn
		err := jiraSvc.AddIssueAttachments(ctx, attachments, issueID99)
		assert.NotNil(t, err)
		expectedError := ""error opening file:some error""
		assert.EqualError(t, err, expectedError)
	})

	t.Run(""uploadAttachment fails at newMultipartWriter"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			}}
		newMultipartWriterFn = func(w io.Writer) (*multipart.Writer, error) {
			return nil, errors.New(errMessage)
		}
		openFn = func(name string) (*os.File, error) {
			return &os.File{}, nil
		}
		attachments := []*entities.Attachment{
			{Filename: myfilePath},
			{Filename: holidayCalendarPath},
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.newMultipartWriter = newMultipartWriterFn
		jiraSvc.open = openFn
		err := jiraSvc.AddIssueAttachments(ctx, attachments, issueID99)
		assert.NotNil(t, err)
		expectedError := errMessage
		assert.EqualError(t, err, expectedError)
	})

	t.Run(""fails at createFormFile"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
		}
		newMultipartWriterFn = func(w io.Writer) (*multipart.Writer, error) {
			return multipart.NewWriter(w), nil
		}
		createFormFileFn = func(w *multipart.Writer, fieldname, filename string) (io.Writer, error) {
			return nil, errors.New(errMessage)
		}
		openFn = func(name string) (*os.File, error) {
			return &os.File{}, nil
		}
		attachments := []*entities.Attachment{
			{Filename: myfilePath},
			{Filename: holidayCalendarPath},
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.newMultipartWriter = newMultipartWriterFn
		jiraSvc.createFormFile = createFormFileFn
		jiraSvc.open = openFn
		err := jiraSvc.AddIssueAttachments(ctx, attachments, issueID99)
		assert.NotNil(t, err)
		expectedError := errMessage
		assert.EqualError(t, err, expectedError)
	})
	t.Run(""fails at copy"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		newMultipartWriterFn = func(w io.Writer) (*multipart.Writer, error) {
			return multipart.NewWriter(w), nil
		}
		createFormFileFn = func(w *multipart.Writer, fieldname, filename string) (io.Writer, error) {
			return nil, nil
		}
		copyFn = func(dst io.Writer, src io.Reader) (int64, error) {
			return 0, errors.New(errMessage)
		}

		openFn = func(name string) (*os.File, error) {
			return &os.File{}, nil
		}

		attachments := []*entities.Attachment{
			{Filename: myfilePath},
			{Filename: holidayCalendarPath},
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		jiraSvc.newMultipartWriter = newMultipartWriterFn
		jiraSvc.createFormFile = createFormFileFn
		jiraSvc.copy = copyFn
		jiraSvc.open = openFn
		err := jiraSvc.AddIssueAttachments(ctx, attachments, issueID99)
		expectedError := errMessage
		assert.NotNil(t, err)
		assert.EqualError(t, err, expectedError)
	})
	t.Run(""fails at copy"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		newMultipartWriterFn = func(w io.Writer) (*multipart.Writer, error) {
			return multipart.NewWriter(w), nil
		}
		createFormFileFn = func(w *multipart.Writer, fieldname, filename string) (io.Writer, error) {
			return nil, nil
		}
		copyFn = func(dst io.Writer, src io.Reader) (int64, error) {
			return 0, errors.New(errMessage)
		}

		openFn = func(name string) (*os.File, error) {
			return &os.File{}, nil
		}

		attachments := []*entities.Attachment{
			{Filename: myfilePath},
			{Filename: holidayCalendarPath},
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		jiraSvc.newMultipartWriter = newMultipartWriterFn
		jiraSvc.createFormFile = createFormFileFn
		jiraSvc.copy = copyFn
		jiraSvc.open = openFn
		err := jiraSvc.AddIssueAttachments(ctx, attachments, issueID99)
		expectedError := errMessage
		assert.NotNil(t, err)
		assert.EqualError(t, err, expectedError)
	})

	t.Run(""fails at writer.Close()"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		ew := &errorWriter{shouldError: true}
		newMultipartWriterFn = func(w io.Writer) (*multipart.Writer, error) {
			return multipart.NewWriter(ew), nil
		}
		createFormFileFn = func(w *multipart.Writer, fieldname, filename string) (io.Writer, error) {
			return nil, nil
		}
		copyFn = func(dst io.Writer, src io.Reader) (int64, error) {
			return 0, nil
		}

		openFn = func(name string) (*os.File, error) {
			return &os.File{}, nil
		}

		attachments := []*entities.Attachment{
			{Filename: myfilePath},
			{Filename: holidayCalendarPath},
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		jiraSvc.newMultipartWriter = newMultipartWriterFn
		jiraSvc.createFormFile = createFormFileFn
		jiraSvc.copy = copyFn
		jiraSvc.open = openFn
		err := jiraSvc.AddIssueAttachments(ctx, attachments, issueID99)
		expectedError := ""simulated write error""
		assert.NotNil(t, err)
		assert.EqualError(t, err, expectedError)
	})
	t.Run(""svc.generateUrl fails"", func(t *testing.T) {
		body := []byte(`{""id"":""54128"", ""key"": ""MNBS-99"", ""self"":""https://localhost:9000/54128""}`)
		response := &http.Response{StatusCode: 201}
		mockHttpClient := mocks.MockHttpClient{
			NewRequestFn: func(ctx context.Context, method, urlStr string, body []byte, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			},
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, nil
			},
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return """", errors.New(errMessage)
		}
		newMultipartWriterFn = func(w io.Writer) (*multipart.Writer, error) {
			return multipart.NewWriter(w), nil
		}
		createFormFileFn = func(w *multipart.Writer, fieldname, filename string) (io.Writer, error) {
			return nil, nil
		}
		copyFn = func(dst io.Writer, src io.Reader) (int64, error) {
			return 0, nil
		}

		openFn = func(name string) (*os.File, error) {
			return &os.File{}, nil
		}

		attachments := []*entities.Attachment{
			{Filename: myfilePath},
			{Filename: holidayCalendarPath},
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		jiraSvc.newMultipartWriter = newMultipartWriterFn
		jiraSvc.createFormFile = createFormFileFn
		jiraSvc.copy = copyFn
		jiraSvc.open = openFn
		err := jiraSvc.AddIssueAttachments(ctx, attachments, issueID99)
		expectedError := errMessage
		assert.NotNil(t, err)
		assert.EqualError(t, err, expectedError)
	})
	t.Run(""svc.client.NewMultiPartRequest fails"", func(t *testing.T) {
		mockHttpClient := mocks.MockHttpClient{
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, errors.New(errMessage)
			}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		newMultipartWriterFn = func(w io.Writer) (*multipart.Writer, error) {
			return multipart.NewWriter(w), nil
		}
		createFormFileFn = func(w *multipart.Writer, fieldname, filename string) (io.Writer, error) {
			return nil, nil
		}
		copyFn = func(dst io.Writer, src io.Reader) (int64, error) {
			return 0, nil
		}

		openFn = func(name string) (*os.File, error) {
			return &os.File{}, nil
		}

		attachments := []*entities.Attachment{
			{Filename: myfilePath},
			{Filename: holidayCalendarPath},
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		jiraSvc.newMultipartWriter = newMultipartWriterFn
		jiraSvc.createFormFile = createFormFileFn
		jiraSvc.copy = copyFn
		jiraSvc.open = openFn
		err := jiraSvc.AddIssueAttachments(ctx, attachments, issueID99)
		expectedError := errMessage
		assert.NotNil(t, err)
		assert.EqualError(t, err, expectedError)
	})

	t.Run(""svc.client.Do fails"", func(t *testing.T) {
		body := []byte(`{""error"":""bad gateway error""}`)
		response := &http.Response{StatusCode: 502}
		mockHttpClient := mocks.MockHttpClient{
			DoFn: func(req *http.Request) (*http.Response, []byte, error) {
				return response, body, errors.New(""bad gateway error"")
			},
			NewMultiPartRequestFn: func(ctx context.Context, method, urlStr string, body io.Reader, reqHeaders map[string]string) (*http.Request, error) {
				return &http.Request{}, nil
			}}
		getFinalUrlFn := func(baseUrl, path string) (string, error) {
			return issueCreationURL, nil
		}
		newMultipartWriterFn = func(w io.Writer) (*multipart.Writer, error) {
			return multipart.NewWriter(w), nil
		}
		createFormFileFn = func(w *multipart.Writer, fieldname, filename string) (io.Writer, error) {
			return nil, nil
		}
		copyFn = func(dst io.Writer, src io.Reader) (int64, error) {
			return 0, nil
		}

		openFn = func(name string) (*os.File, error) {
			return &os.File{}, nil
		}

		attachments := []*entities.Attachment{
			{Filename: myfilePath},
			{Filename: holidayCalendarPath},
		}
		jiraSvc := jiraSvc{client: mockHttpClient}
		jiraSvc.generateUrl = getFinalUrlFn
		jiraSvc.newMultipartWriter = newMultipartWriterFn
		jiraSvc.createFormFile = createFormFileFn
		jiraSvc.copy = copyFn
		jiraSvc.open = openFn
		err := jiraSvc.AddIssueAttachments(ctx, attachments, issueID99)
		expectedError := ""bad gateway error""
		assert.NotNil(t, err)
		assert.EqualError(t, err, expectedError)
	})
}"
"func (svc incidentSvc) PatchIncident(payload []byte, key, value string) (interface{}, error) {
	if svc.authToken == nil || svc.client == nil {
		return nil, errors.New(errIncidentSvcNotInit)
	}
	//Build Patch URL
	patchURL := fmt.Sprintf(""%s/%s/%s"", svc.incidentURL, key, value)
	req, err := http.NewRequest(http.MethodPatch, patchURL, bytes.NewBuffer(payload))
	if err != nil {
		logger.L.Error(errFormingReqObj, zap.Error(err))
		return nil, err
	}
	logger.L.Info(""Incident PATCH URL: "", zap.Any(""URL"", req.URL.String()))
	req = helper.JSONHeadersMiddleware(req, svc.authToken.AccessToken)
	return helper.HTTPClient(req, svc.client)
}","func TestPatchIncident(t *testing.T) {
	t.Run(""Successfully patches incident"", func(t *testing.T) {
		mockAuthSvc := &mocks.MockAuthSvc{
			Token: &entities.AuthToken{AccessToken: ""testToken""},
		}

		mockServer := mockServer(http.StatusOK, []byte(`{""result"": ""success""}`))
		defer mockServer.Close()

		service := NewIncidentService(mockAuthSvc, mockServer.URL+""/incident"", &http.Client{})

		payload := []byte(`{""key"":""value""}`)
		result, err := service.PatchIncident(payload, ""key"", ""value"")

		assert.NoError(t, err)

		expectedResult := map[string]interface{}{""result"": ""success""}
		assert.Equal(t, expectedResult, result)
	})

	t.Run(""Fails to patch incident"", func(t *testing.T) {
		mockAuthSvc := &mocks.MockAuthSvc{
			Token: &entities.AuthToken{AccessToken: ""testToken""},
		}
	
		mockServer := mockServer(http.StatusOK, []byte(`{""result"": ""success""}`))
		defer mockServer.Close()
	
		service := NewIncidentService(mockAuthSvc, ""http://%invalid%url"", &http.Client{})
	
		payload := []byte(`{""key"":""value""}`)
		_, err := service.PatchIncident(payload, ""key"", ""value"")
	
		assert.Error(t, err)
	})
}"
"func IsReady() bool {
	ctx := context.Background()
	repoReady := repo.Health(ctx) == nil
	logger.L.Info(""unit readiness check"", zap.Bool(""publisher"", publisher.IsReady()),
		zap.Bool(""secretStore"", secretStore != nil), zap.Bool(""tracer"", tracer != nil),
		zap.Bool(""mss"", mss.Ready()), zap.Bool(""repo"", repoReady))
	return publisher.IsReady() && secretStore != nil && tracer != nil &&
		mssStore != nil && mssStore.IsReady(ctx) == nil && repoReady
}","func TestIsReady(t *testing.T) {
	type testCase struct {
		name             string
		publisherReady   bool
		secretStoreReady bool
		tracerReady      bool
		mssStoreReady    bool
		mssReadyCheck    bool
		repoReady        bool
		expectedResult   bool
	}

	testCases := []testCase{
		{
			name:             ""All Dependencies Ready"",
			publisherReady:   true,
			secretStoreReady: true,
			tracerReady:      true,
			mssStoreReady:    true,
			mssReadyCheck:    true,
			repoReady:        true,
			expectedResult:   true,
		},
		{
			name:             ""Publisher Not Ready"",
			publisherReady:   false,
			secretStoreReady: true,
			tracerReady:      true,
			mssStoreReady:    true,
			mssReadyCheck:    true,
			repoReady:        true,
			expectedResult:   false,
		},
		{
			name:             ""Secret Store Missing"",
			publisherReady:   true,
			secretStoreReady: false,
			tracerReady:      true,
			mssStoreReady:    true,
			mssReadyCheck:    true,
			repoReady:        true,
			expectedResult:   false,
		},
		{
			name:             ""Tracer Not Ready"",
			publisherReady:   true,
			secretStoreReady: true,
			tracerReady:      false,
			mssStoreReady:    true,
			mssReadyCheck:    true,
			repoReady:        true,
			expectedResult:   false,
		},
		{
			name:             ""MSS Store Missing"",
			publisherReady:   true,
			secretStoreReady: true,
			tracerReady:      true,
			mssStoreReady:    false,
			mssReadyCheck:    true,
			repoReady:        true,
			expectedResult:   false,
		},
		{
			name:             ""MSS Store Readiness Fails"",
			publisherReady:   true,
			secretStoreReady: true,
			tracerReady:      true,
			mssStoreReady:    true,
			mssReadyCheck:    false,
			repoReady:        true,
			expectedResult:   false,
		},
		{
			name:             ""Repo Not Ready"",
			publisherReady:   true,
			secretStoreReady: true,
			tracerReady:      true,
			mssStoreReady:    true,
			mssReadyCheck:    true,
			repoReady:        false,
			expectedResult:   false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			if tc.publisherReady {
				p := pubmock.NewService()
				InitializePublishSvc(p)
			} else {
				InitializePublishSvc(nil)
			}

			if tc.secretStoreReady {
				secretStore = secstr.NewMockSecretStore(
					secstr.WithSetSecret(func(ctx context.Context, key, value string) error {
						return nil
					}),
				)
			} else {
				secretStore = nil
			}

			if tc.tracerReady {
				tracer = opentelemetry.MockTracer{}
			} else {
				tracer = nil
			}

			if tc.mssStoreReady {
				mssStore = secstr.NewMockSecretStore(
					secstr.WithIsReady(func(ctx context.Context) error {
						if tc.mssReadyCheck {
							return nil
						}
						return errors.New(""mss store readiness failed"")
					}),
				)
			} else {
				mssStore = nil
			}

			if tc.repoReady {
				repo = repomock.MockRepository{
					HealthFn: func(ctx context.Context) error {
						return nil
					},
				}
			} else {
				repo = repomock.MockRepository{
					HealthFn: func(ctx context.Context) error {
						return errors.New(""repo health check failed"")
					},
				}
			}

			result := IsReady()
			assert.Equal(t, tc.expectedResult, result)
		})
	}
}"
"func GetPlan(id string) ([]byte, error) {
	if client == nil {
		return nil, errors.New(""plan service not initialized"")
	}
	url_, err := url.ParseRequestURI(fmt.Sprintf(""%s/%s"", baseURL, id))
	if err != nil {
		return nil, err
	}
	header := http.Header{}
	header.Add(""Content-Type"", ""application/json"")
	resp, err := client.Do(&http.Request{
		Method: http.MethodGet,
		URL:    url_,
		Header: header,
	})
	if err != nil {
		return nil, fmt.Errorf(""cant fetch plan: %w"", err)
	}
	defer resp.Body.Close()
	return io.ReadAll(resp.Body)
}","func TestGetPlan(t *testing.T) {
	t.Run(""should return error if client is nil"", func(t *testing.T) {
		baseURL = ""http://test.com""
		client = nil

		_, err := GetPlan(""testid"")
		assert.Error(t, err)
		assert.Equal(t, ""plan service not initialized"", err.Error())
	})

	t.Run(""should return error for invalid URL"", func(t *testing.T) {
		baseURL = ""http://test.com\\invalid-url"" 
		client = &http.Client{}

		_, err := GetPlan(""testid"")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), ""invalid character"")
	})

	t.Run(""should return error for failed HTTP request"", func(t *testing.T) {
		baseURL = ""http://test.com""
		client = &http.Client{
			Transport: roundTripper(func(req *http.Request) (*http.Response, error) {
				return nil, errors.New(""cant fetch plan"")
			}),
		}

		_, err := GetPlan(""testid"")
		assert.Error(t, err)
	})

	t.Run(""should return response body on success"", func(t *testing.T) {
		baseURL = ""http://test.com""
		expectedBody := []byte(`{""plan"":""testplan""}`)
		client = &http.Client{
			Transport: roundTripper(func(req *http.Request) (*http.Response, error) {
				assert.Equal(t, http.MethodGet, req.Method)
				assert.Equal(t, ""application/json"", req.Header.Get(""Content-Type""))
				assert.Equal(t, ""http://test.com/testid"", req.URL.String())

				return &http.Response{
					StatusCode: http.StatusOK,
					Body:       io.NopCloser(bytes.NewReader(expectedBody)),
				}, nil
			}),
		}

		body, err := GetPlan(""testid"")
		assert.NoError(t, err)
		assert.Equal(t, expectedBody, body)
	})
}"
"func (svc Servicenow) IsValid() bool {
	return checkEmptyValues(svc)
}","func TestIsValid(t *testing.T) {
	tests := []struct {
		name     string
		input    Servicenow
		expected bool
	}{
		{
			name: ""Valid configuration"",
			input: Servicenow{
				Username:         ""test_user"",
				Password:         ""test_password"",
				ClientID:         ""client_id"",
				ClientSecret:     ""client_secret"",
				Env:              ""test"",
				Version:          ""1.0"",
				GrantType:        ""password"",
				Scope:            ""read"",
				URL:              ""http://test.com"",
				Path:             ServiceNowServerPath{Auth: ""testAuthPath"", Incident: ""testIncidentPath"", ChangeRequest: ""testChangePath"", Approval: ""testApprovalPath""},
				TimeoutInSeconds: 30,
			},
			expected: true,
		},
		{
			name: ""Empty Username"",
			input: Servicenow{
				Password:         ""test_password"",
				ClientID:         ""client_id"",
				ClientSecret:     ""client_secret"",
				Env:              ""test"",
				Version:          ""1.0"",
				GrantType:        ""password"",
				Scope:            ""read"",
				URL:              ""http://test.com"",
				Path:             ServiceNowServerPath{Auth: ""testAuthPath"", Incident: ""testIncidentPath"", ChangeRequest: ""testChangePath"", Approval: ""testApprovalPath""},
				TimeoutInSeconds: 30,
			},
			expected: false,
		},
		{
			name: ""Empty Path values"",
			input: Servicenow{
				Username:         ""test_user"",
				Password:         ""test_password"",
				ClientID:         ""client_id"",
				ClientSecret:     ""client_secret"",
				Env:              ""test"",
				Version:          ""1.0"",
				GrantType:        ""password"",
				Scope:            ""read"",
				URL:              ""http://test.com"",
				Path:             ServiceNowServerPath{},
				TimeoutInSeconds: 30,
			},
			expected: false,
		},
		{
			name: ""Zero Timeout"",
			input: Servicenow{
				Username:         ""test_user"",
				Password:         ""test_password"",
				ClientID:         ""client_id"",
				ClientSecret:     ""client_secret"",
				Env:              ""test"",
				Version:          ""1.0"",
				GrantType:        ""password"",
				Scope:            ""read"",
				URL:              ""http://test.com"",
				Path:             ServiceNowServerPath{Auth: ""testAuthPath"", Incident: ""testIncidentPath"", ChangeRequest: ""testChangePath"", Approval: ""testApprovalPath""},
				TimeoutInSeconds: 0,
			},
			expected: false,
		},
		{
			name: ""Completely Empty Configuration"",
			input: Servicenow{},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.input.IsValid(); got != tt.expected {
				t.Errorf(""Servicenow.IsValid() = %v, expected %v"", got, tt.expected)
			}
		})
	}
}"
"func (svc approvalSvc) GetApproval(params map[string]string) (interface{}, error) {
	if svc.authToken == nil || svc.client == nil {
		return nil, errors.New(""Approval service is not initialized"")
	}
	req, err := http.NewRequest(http.MethodGet, svc.approvalURL, nil)
	if err != nil {
		logger.L.Error(""Error while forming the Request object"", zap.Error(err))
		return nil, err
	}
	//Build Get URL Query
	query := helper.BuildURLQuery(req, params)
	req.URL.RawQuery = query.Encode()
	logger.L.Info(""Approval URL formed "", zap.Any(""URL"", req.URL.String()))
	req = helper.JSONHeadersMiddleware(req, svc.authToken.AccessToken)

	return helper.HTTPClient(req, svc.client)
}","func TestGetApproval(t *testing.T) {
	mockAuthToken := &entities.AuthToken{AccessToken: ""testAccessToken""}
	approvalURL := ""http://test.com/approval""

	t.Run(""Successfully gets approval"", func(t *testing.T) {
		mockTransport := &mocks.MockRoundTripper{
			RoundTripFn: func(req *http.Request) *http.Response {
				assert.Equal(t, req.URL.RawQuery, ""key=value"", ""Expected query parameters to match"")
				return &http.Response{
					StatusCode: http.StatusOK,
					Body:       ioutil.NopCloser(strings.NewReader(`{""status"": ""success""}`)),
					Header:     make(http.Header),
				}
			},
		}
		mockClient := &http.Client{Transport: mockTransport}

		mockSvc := approvalSvc{
			authToken:   mockAuthToken,
			approvalURL: approvalURL,
			client:      mockClient,
		}

		params := map[string]string{""key"": ""value""}
		result, err := mockSvc.GetApproval(params)
		assert.NoError(t, err, ""Expected no error"")
		assert.NotNil(t, result, ""Expected a valid response"")
		assert.Equal(t, ""success"", result.(map[string]interface{})[""status""], ""Expected status to be 'success'"")
	})

	t.Run(""Fails due to uninitialized service"", func(t *testing.T) {
		mockSvc := approvalSvc{}
		params := map[string]string{""key"": ""value""}

		result, err := mockSvc.GetApproval(params)
		assert.Error(t, err, ""Expected an error"")
		assert.Nil(t, result, ""Expected result to be nil"")
	})

	t.Run(""Fails to create HTTP request"", func(t *testing.T) {
		client := &http.Client{}
		mockSvc := approvalSvc{
			authToken:   mockAuthToken,
			approvalURL: ""http://invalid-url%"",
			client: client,
		}
		params := map[string]string{""key"": ""value""}

		result, err := mockSvc.GetApproval(params)
		assert.Error(t, err, ""Expected an error due to invalid URL"")
		assert.Nil(t, result, ""Expected result to be nil"")
	})
}"
"func NewApprovalService(tokenSvc interfaces.ServiceNowAuthSvc, approvalURL string, client *http.Client) interfaces.ApprovalSvc {
	token, err := tokenSvc.GetAuthToken()
	if err != nil {
		logger.L.Error(""Failed to initialise token "", zap.Error(err))
		return nil
	}
	return approvalSvc{authToken: token, approvalURL: approvalURL, client: client}
}","func TestNewApprovalService(t *testing.T) {
	t.Run(""Successfully initializes service"", func(t *testing.T) {
		mockSvc := &mocks.MockAuthSvc{
			GetAuthTokenFn: func() (*entities.AuthToken, error) {
				return &entities.AuthToken{AccessToken: ""testAccessToken""}, nil
			},
		}
		client := &http.Client{}
		svc := NewApprovalService(mockSvc, ""http://test.com/approval"", client)

		assert.NotNil(t, svc, ""Expected service to be initialized"")
	})

	t.Run(""Fails to initialize service"", func(t *testing.T) {
		mockSvc := &mocks.MockAuthSvc{
			GetAuthTokenFn: func() (*entities.AuthToken, error) {
				return nil, errors.New(""token error"")
			},
		}
		client := &http.Client{}
		svc := NewApprovalService(mockSvc, ""http://test.com/approval"", client)

		assert.Nil(t, svc)
	})
}"
